<!DOCTYPE html>
<html lang="en">

  <head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <title>
    
      Clojure Data Science: Ingesting Your Gmail Inbox &middot; Matt Gauger
    
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="/css/main.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Libre+Baskerville:400,400i,700">

  <!-- Feeds -->
  <link rel='alternate' type='application/atom+xml' href='/atom.xml'>
</head>


  <body>
    <nav class="nav">
      <div class="nav-container">
        <a href="https://blog.mattgauger.com">
          <h2 class="nav-title">Matt Gauger</h2>
        </a>
        <ul>
          <li><a href="/about">About</a></li>
          <li><a href="/archives">Blog Archives</a></li>
          <li><a href="/open-source">Open Source</a></li>
        </ul>
    </div>
  </nav>

    <main>
      <div class="post">
  <div class="post-info">
    <span>Written by</span> Matt Gauger

    
      <br>
      <span>on&nbsp;</span><time datetime="2014-03-30 14:44:00 -0500">March 30, 2014</time>
    
  </div>

  <h1 class="post-title">Clojure Data Science: Ingesting Your Gmail Inbox</h1>
  <div class="post-line"></div>

  <hr />

<p>This is Part 1 of a series of blog posts inspired by the exercises from <a href="http://shop.oreilly.com/product/0636920025054.do">Agile Data Science</a> with Clojure. You may be interested in my <a href="/2014/03/14/agile-data-science-review-and-thoughts/">review</a> of the book.</p>

<hr />

<p>For this blog post series, we are going to use your Gmail inbox as a dataset for an exploration of data science practices. Namely, we will use your email for machine learning and natural language processing applications. Email makes interesting data to process:</p>

<ul>
  <li>it has lots of metadata that we can use as features <a href="#cds-gmail-footnote-1" name="cds-gmail-footnote-1-return">[1]</a></li>
  <li>we can model the relationships of senders and receivers as a graph</li>
  <li>each message has a body of text associated with it that we can analyze</li>
  <li>gaining insights from our personal communication is far more interesting than using an open data set!</li>
</ul>

<p><strong>Note:</strong> This is not an intro-to-Clojure blog post. If you need a tutorial that starts with the basics, I recommend the <a href="http://aphyr.com/tags/Clojure-from-the-ground-up">Clojure from the ground up</a> blog post series by <a href="https://twitter.com/aphyr">Aphyr</a>. It does an excellent job at introducing concepts in Clojure.</p>

<p>In this post, I follow my typical Clojure workflow: I open a REPL and begin exploring the problem space. I look at individual pieces of data and start transforming them. When I write some functionality that I like for one piece of data, I try to extract it into the source code as a function that can work for any data our project may see. In this way, we can build up the project to contain the functions that are necessary to get to our goal.</p>

<p>So what is our goal for this blog post? Well, we want to fetch all emails from our Gmail inbox. We want to get metadata for each email, including things like who sent it and when it was sent. Then, we want to save the messages into a database so we can do further processing in later posts.</p>

<p>Starting off, make a new basic Clojure project with lein. I’ve named my project <a href="https://github.com/mathias/autodjinn">autodjinn</a> after <a href="http://en.wikipedia.org/wiki/Email#Origin">AUTODIN</a>, one of the first email networks. You can use the <a href="https://github.com/mathias/autodjinn">repo</a> to refer to and to clone to follow along. At the beginning of each subsequent post, I’ll provide a SHA that you can reset the code to. Feel free to name your project whatever you want; just be sure to pay attention to the changes in filenames and namespaces as we go along!</p>

<p>Create the project and enter it:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>lein new autodjinn

<span class="nb">cd </span>autodjinn
</code></pre></div></div>

<p>To import our Gmail data, we will use a Clojure library called <a href="https://github.com/owainlewis/clojure-mail">clojure-mail</a>. Clojure-mail is still under active development and is likely to change. For this blog post, we’ll be using version <code class="language-plaintext highlighter-rouge">0.1.6</code> to ensure compatibility between the code in this post and the library.</p>

<p>Edit <code class="language-plaintext highlighter-rouge">project.clj</code> to contain your information and add the <code class="language-plaintext highlighter-rouge">[clojure-mail "0.1.6"]</code> dependency:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">defproject</span><span class="w"> </span><span class="n">autodjinn</span><span class="w"> </span><span class="s">"0.1.0-SNAPSHOT"</span><span class="w">
  </span><span class="no">:description</span><span class="w"> </span><span class="s">"An email analysis tool"</span><span class="w">
  </span><span class="no">:url</span><span class="w"> </span><span class="s">"CHANGEME"</span><span class="w">
  </span><span class="no">:license</span><span class="w"> </span><span class="p">{</span><span class="no">:name</span><span class="w"> </span><span class="s">"Eclipse Public License"</span><span class="w">
            </span><span class="no">:url</span><span class="w"> </span><span class="s">"http://www.eclipse.org/legal/epl-v10.html"</span><span class="p">}</span><span class="w">
  </span><span class="no">:dependencies</span><span class="w"> </span><span class="p">[[</span><span class="n">org.clojure/clojure</span><span class="w"> </span><span class="s">"1.5.1"</span><span class="p">]</span><span class="w">
                 </span><span class="p">[</span><span class="n">clojure-mail</span><span class="w"> </span><span class="s">"0.1.6"</span><span class="p">]])</span><span class="w">
</span></code></pre></div></div>

<p>We’ll start by working in <code class="language-plaintext highlighter-rouge">src/autodjinn/core.clj</code> and later move the functionality out into a script for our email import task. Open up the file in your favorite editor and launch a REPL.</p>

<p>In your REPL, <code class="language-plaintext highlighter-rouge">(use 'autodjinn.core)</code> and verify it worked by running <code class="language-plaintext highlighter-rouge">(foo "MYNAME")</code>. You should see “MYNAME Hello, World!” printed out. Feel free to remove the <code class="language-plaintext highlighter-rouge">(defn foo…)</code> in <code class="language-plaintext highlighter-rouge">core.clj</code> now. We will not need it.</p>

<p>You may want to use something like Emacs’ <a href="https://github.com/clojure-emacs/cider">cider</a> or LightTable’s InstaREPL as your REPL environment. But you can use the regular Clojure REPL to build this project, as well. If you are not working with a REPL integrated to your editor, you will need to run <code class="language-plaintext highlighter-rouge">(use 'autodjinn.core :reload)</code> to force a reload of the code each time you save.</p>

<h2 id="connecting-to-gmail">Connecting to Gmail</h2>

<p>Our first goal is to connect to our inbox and verify that we can read email from it. To do that, we’re going to need to use our Gmail address and password — which we don’t want to put into our source files. <strong>It’s bad practice to put a password or a private key into a source file or check it into our repo! Just don’t do it!</strong></p>

<p>Instead, we will use a nice library called <a href="https://github.com/james-henderson/nomad">nomad</a> to load a config file containing our email address and password. We will add the config file to <code class="language-plaintext highlighter-rouge">.gitignore</code> so that it is never saved into our code.</p>

<p>Add the line <code class="language-plaintext highlighter-rouge">[jarohen/nomad "0.6.3"]</code> to your <code class="language-plaintext highlighter-rouge">project.clj</code> dependencies before moving on, and run <code class="language-plaintext highlighter-rouge">lein deps</code> in a console to pull in the dependency.</p>

<p>Back in our <code class="language-plaintext highlighter-rouge">core.clj</code> add the require statements for <code class="language-plaintext highlighter-rouge">clojure-mail</code> and <code class="language-plaintext highlighter-rouge">nomad</code> to your ns macro like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">ns</span><span class="w"> </span><span class="n">autodjinn.core</span><span class="w">
  </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="p">[</span><span class="n">clojure-mail.core</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="n">all</span><span class="p">]</span><span class="w">
           </span><span class="p">[</span><span class="n">clojure-mail.message</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">message</span><span class="p">]</span><span class="w">
           </span><span class="p">[</span><span class="n">nomad</span><span class="w"> </span><span class="no">:refer</span><span class="w"> </span><span class="p">[</span><span class="n">defconfig</span><span class="p">]]]))</span><span class="w">
</span></code></pre></div></div>

<p>Then create a new file in <code class="language-plaintext highlighter-rouge">resources/config/autodjinn-config.edn</code>. It should look like this, with your email address and password filled in:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:gmail-username</span><span class="w"> </span><span class="s">"you@gmail.com"</span><span class="w">
 </span><span class="no">:gmail-password</span><span class="w"> </span><span class="s">"yourpassword"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Now open up your <code class="language-plaintext highlighter-rouge">.gitignore</code> file and add the following line to it:</p>

<div class="language-shell highlighter-rouge"><div class="highlight"><pre class="highlight"><code>resources/config/<span class="k">*</span><span class="nt">-config</span>.edn
</code></pre></div></div>

<p>Following <a href="https://github.com/james-henderson/nomad#hello-world">nomad’s README</a>, we need to load our config file and pull out our <code class="language-plaintext highlighter-rouge">gmail-username</code> and <code class="language-plaintext highlighter-rouge">gmail-password</code> keys. We add to the following to <code class="language-plaintext highlighter-rouge">core.clj</code> after the <code class="language-plaintext highlighter-rouge">ns</code> macro:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; in autodjinn/core.clj:</span><span class="w">
</span><span class="p">(</span><span class="nf">defconfig</span><span class="w"> </span><span class="n">autodjinn-config</span><span class="w"> </span><span class="p">(</span><span class="nf">io/resource</span><span class="w"> </span><span class="s">"config/autodjinn-config.edn"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">gmail-username</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">autodjinn-config</span><span class="p">)</span><span class="w"> </span><span class="no">:gmail-username</span><span class="p">))</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">gmail-password</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">autodjinn-config</span><span class="p">)</span><span class="w"> </span><span class="no">:gmail-password</span><span class="p">))</span><span class="w">

</span><span class="c1">;; Note that we must call autodjinn-config as a function</span><span class="w">
</span><span class="c1">;; to use it as a map!</span><span class="w">
</span></code></pre></div></div>

<p>Using the <code class="language-plaintext highlighter-rouge">get</code> function here is a safe lookup for maps that returns <code class="language-plaintext highlighter-rouge">nil</code> if nothing is found for the key. Back in our REPL, we can see this in action with some quick experimentation:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">mymap</span><span class="w"> </span><span class="p">{</span><span class="no">:a</span><span class="w"> </span><span class="s">"b"</span><span class="p">})</span><span class="w">
</span><span class="c1">;=&gt; #'user/mymap</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">mymap</span><span class="w"> </span><span class="no">:a</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; "b"</span><span class="w">
</span><span class="n">user=&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="n">mymap</span><span class="w"> </span><span class="no">:c</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span></code></pre></div></div>

<p>We could also use the shorter <code class="language-plaintext highlighter-rouge">(:keyname mymap)</code> syntax here, since symbols are an invocable function that looks up a key in a map. But the <code class="language-plaintext highlighter-rouge">get</code> function reads better than <code class="language-plaintext highlighter-rouge">(:gmail-username (autodjinn-config))</code> in my opinion.</p>

<p>In your REPL, you should now be able to get the values for <code class="language-plaintext highlighter-rouge">gmail-username</code> and <code class="language-plaintext highlighter-rouge">gmail-password</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="n">autodjinn.core/gmail-username</span><span class="w">
</span><span class="c1">;=&gt; "myname@gmail.com"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">autodjinn.core/gmail-password</span><span class="w">
</span><span class="c1">;=&gt; "mypassword"</span><span class="w">
</span></code></pre></div></div>

<p>Note that since I’m in the <code class="language-plaintext highlighter-rouge">user</code> namespace here, I had to qualify the vars with their <code class="language-plaintext highlighter-rouge">autodjinn.core</code> namespace. If this is confusing, you might want to read up on <a href="http://clojure-doc.org/articles/language/namespaces.html">namespaces in Clojure</a> before moving on. (See also: the ‘Namespaces’ section in <a href="http://aphyr.com/posts/311-clojure-from-the-ground-up-logistics">Clojure from the ground up: logistics</a>.)</p>

<p><code class="language-plaintext highlighter-rouge">clojure-mail</code> requires us to open a connection to Gmail with the <code class="language-plaintext highlighter-rouge">gen-store</code> function (<a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/src/clojure_mail/core.clj#L80-L83">src</a>). We then pass that connection around to various functions to interact with our inbox. Define a var called <code class="language-plaintext highlighter-rouge">my-store</code> in your <code class="language-plaintext highlighter-rouge">core.clj</code> that does this with our email address and password:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; in core.clj after defining gmail-username and gmail-password:</span><span class="w">
</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-store</span><span class="w"> </span><span class="p">(</span><span class="nf">gen-store</span><span class="w"> </span><span class="n">gmail-username</span><span class="w"> </span><span class="n">gmail-password</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Make sure the <code class="language-plaintext highlighter-rouge">(def my-store…</code> above has been run in your REPL and then take a look at our open connection:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="w">
</span><span class="c1">;=&gt; #&lt;IMAPSSLStore imaps://myname%gmail.com@imap.gmail.com&gt;</span><span class="w">
</span></code></pre></div></div>

<p>The type of <code class="language-plaintext highlighter-rouge">my-store</code> should be an <code class="language-plaintext highlighter-rouge">IMAPSSLStore</code> as above. If it didn’t work, you’ll see a string error message when you try to define <code class="language-plaintext highlighter-rouge">my-store</code>.</p>

<h2 id="your-inbox-as-a-list">Your inbox as a list</h2>

<p>Now we’ll use our REPL to build up a function that will eventually import all of our email. To start, we can use the <code class="language-plaintext highlighter-rouge">inbox</code> function (<a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/src/clojure_mail/core.clj#L198-L201">src</a>) from <code class="language-plaintext highlighter-rouge">clojure-mail</code> to get a seq of messages in our inbox. Note that since it is a seq and inboxes can be very large, we limit it with the <code class="language-plaintext highlighter-rouge">take</code> function.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">use</span><span class="w"> </span><span class="ss">'clojure-mail.core</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; (#&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@676ef6f3&gt; #&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@26170092&gt; #&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@302684c7&gt; #&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@30d73d83&gt;)</span><span class="w">
</span></code></pre></div></div>

<p>If everything is working, you should see a list of of the <code class="language-plaintext highlighter-rouge">IMAPMessage</code>s returned by the last line in your REPL.</p>

<p>What if, instead, we wanted to loop over many messages and print out their subjects? We can pull in the <code class="language-plaintext highlighter-rouge">message</code> namespace (<a href="https://github.com/owainlewis/clojure-mail/blob/master/src/clojure_mail/message.clj">src</a>) from <code class="language-plaintext highlighter-rouge">clojure-mail</code>, which gives us convenience functions for getting at message data.</p>

<p>You’ll have to be careful running this next line — on a large inbox it’ll print out the subject of everything in your inbox! If you have a lot of messages, consider wrapping the call to <code class="language-plaintext highlighter-rouge">inbox</code> in a <code class="language-plaintext highlighter-rouge">take</code> as above.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">clojure-mail.message</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">message</span><span class="p">])</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="p">)]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">msg</span><span class="p">)))</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">Testing!</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">

</span><span class="c1">;; With a limit on the number of subjects to print:</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="w"> </span><span class="p">(</span><span class="nb">take</span><span class="w"> </span><span class="mi">2</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="p">))]</span><span class="w">
  </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">msg</span><span class="p">)))</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">Testing!</span><span class="w">
</span><span class="n">nil</span><span class="w">
</span></code></pre></div></div>

<p>Those are the subject lines of the 4 messages in the inbox of my test account, so I know that this is working. Save our <code class="language-plaintext highlighter-rouge">doseq</code> line into a function called <code class="language-plaintext highlighter-rouge">ingest-inbox</code>; we’ll come back to it later. In <code class="language-plaintext highlighter-rouge">core.clj</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ingest-inbox</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">msg</span><span class="p">))))</span><span class="w">
</span></code></pre></div></div>

<h2 id="examining-messages">Examining messages</h2>

<p>Before we move on, let’s take a look at an individual message and what we can get out of it from the <code class="language-plaintext highlighter-rouge">message</code> namespace.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@71999260&gt;</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-msg</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">autodjinn.core/my-store</span><span class="p">)))</span><span class="w">
</span><span class="c1">;=&gt; #'user/my-msg</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; "Subject 3"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">message/id</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; "&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com&gt;"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">message/from</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; "Matt Gauger &lt;contact@mattgauger.com&gt;"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">message/to</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; ("contact@mattgauger.com")</span><span class="w">
</span><span class="c1">;; note that this is a seq!</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">message/message-body</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; ({:content-type "TEXT/PLAIN; charset=ISO-8859-1", :body "Body\r\n"} {:content-type "TEXT/HTML; charset=ISO-8859-1", :body "&lt;div dir=\"ltr\"&gt;Body&lt;/div&gt;\r\n"})</span><span class="w">
</span></code></pre></div></div>

<p>From this, we can see a few things:</p>

<ul>
  <li>The ID returned by <code class="language-plaintext highlighter-rouge">message/id</code> looks like a good candidate to get good unique IDs for each message when we store the messages. But we might want to strip off those angle brackets first.</li>
  <li>The <code class="language-plaintext highlighter-rouge">message/message-body</code> function doesn’t return a string of the body. Instead, it returns a list of maps which contains the <code class="language-plaintext highlighter-rouge">text/plain</code> form of the body and the <code class="language-plaintext highlighter-rouge">text/html</code> form. We will have to extract each from the map so that we can use the plaintext version for things like language processing. We’ll also keep the HTML version in case we need it later.</li>
  <li>If you started digging in to the <code class="language-plaintext highlighter-rouge">message</code> namespace’s source you may have noticed that we don’t have functions for getting date sent or date received for a message. Nor can we get a list of addresses CCed or BCCed for the message. We’ll have to write those functions ourselves.</li>
</ul>

<h2 id="cleaning-up-the-ids">Cleaning up the IDs</h2>

<p>Let’s focus on writing a function to clean up the ID returned by the <code class="language-plaintext highlighter-rouge">message/id</code> function. Recall that such IDs look like <code class="language-plaintext highlighter-rouge">&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com&gt;</code></p>

<p>The <code class="language-plaintext highlighter-rouge">clojure.string</code> namespace provides a <code class="language-plaintext highlighter-rouge">replace</code> function which does simple replacement on a string. We can use it like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-id</span><span class="w"> </span><span class="p">(</span><span class="nf">message/id</span><span class="w"> </span><span class="n">my-msg</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #'user/my-id</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">my-id</span><span class="w">
</span><span class="c1">;=&gt; "&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com&gt;"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="n">my-id</span><span class="w"> </span><span class="s">"&gt;"</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; "&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="n">my-id</span><span class="w"> </span><span class="s">"&lt;"</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; "CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com&gt;"</span><span class="w">
</span></code></pre></div></div>

<p>That worked for replacing the angle brackets for the original string. But remember that data structures are immutable in Clojure, including strings. Replacing the first angle bracket didn’t change the original string when we tried to replace the other angle bracket. We need something that allows us to build up an intermediate value and pass it to the next function. For that, we will use the <a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3e">thread-first</a> macro: <code class="language-plaintext highlighter-rouge">-&gt;</code>. It is easiest if I show the macro in use with some comments showing what the intermediate values would be at each step:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">my-id</span><span class="w"> </span><span class="c1">;; "&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com&gt;"</span><span class="w">
    </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="s">"&gt;"</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">  </span><span class="c1">;; "&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com"</span><span class="w">
    </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="s">"&lt;"</span><span class="w"> </span><span class="s">""</span><span class="p">))</span><span class="w"> </span><span class="c1">;; "CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com"</span><span class="w">
</span><span class="c1">;=&gt; "CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com"</span><span class="w">
</span></code></pre></div></div>

<p>It is called the <strong>thread-first</strong> macro because it threads through the first argument to each function. In this case, <code class="language-plaintext highlighter-rouge">clojure.string/replace</code>’s first argument is the string to replace on. So the each successively returned value gets passed to the next function above.</p>

<p>Now that we’ve figured out how to clean up that ID, we will create a function to clean up any ID we pass it. In <code class="language-plaintext highlighter-rouge">core.clj</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">remove-angle-brackets</span><span class="w"> </span><span class="p">[</span><span class="n">string</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">string</span><span class="w">
      </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="s">"&gt;"</span><span class="w"> </span><span class="s">""</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">clojure.string/replace</span><span class="w"> </span><span class="s">"&lt;"</span><span class="w"> </span><span class="s">""</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<h2 id="extracting-the-message-bodies">Extracting the message bodies</h2>

<p>Recall the <code class="language-plaintext highlighter-rouge">message/message-body</code> call above:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">message/message-body</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; ({:content-type "TEXT/PLAIN; charset=ISO-8859-1", :body "Body\r\n"} {:content-type "TEXT/HTML; charset=ISO-8859-1", :body "&lt;div dir=\"ltr\"&gt;Body&lt;/div&gt;\r\n"})</span><span class="w">
</span></code></pre></div></div>

<p>Ideally, we want to write a function that can get the <code class="language-plaintext highlighter-rouge">text/plain</code> body out of this value, and another function that can get the <code class="language-plaintext highlighter-rouge">text/html</code> body out. Notice that the <code class="language-plaintext highlighter-rouge">:content-type</code> values aren’t quite so simple as just selecting the item in the list where the string <code class="language-plaintext highlighter-rouge">text/plain</code> appears. We will need our function to ignore the additional information in the <code class="language-plaintext highlighter-rouge">:content-type</code> value, which includes things like string encodings.</p>

<p>Let’s look at just the first map in the list returned by <code class="language-plaintext highlighter-rouge">message/message-body</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-bodies</span><span class="w"> </span><span class="p">(</span><span class="nf">message/message-body</span><span class="w"> </span><span class="n">my-msg</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt;#'user/my-bodies</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; {:content-type "TEXT/PLAIN; charset=ISO-8859-1", :body "Body\r\n"}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:content-type</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; "TEXT/PLAIN; charset=ISO-8859-1"</span><span class="w">
</span></code></pre></div></div>

<p>If we build a predicate function that can detect when the <code class="language-plaintext highlighter-rouge">:content-type</code> key is the type we want, we can use it in a <code class="language-plaintext highlighter-rouge">filter</code> function to choose the correct type of body in our functions.</p>

<p>Notice that <code class="language-plaintext highlighter-rouge">TEXT/PLAIN</code> and <code class="language-plaintext highlighter-rouge">TEXT/HTML</code> are always separated from the rest of the content-type by a semicolon, and it always appears first. You’d have to look at a few messages from your inbox to arrive at the same conclusion, but I’ve already done the work and can assure you that the previous statement is true.</p>

<p>Then, an easy to to get at the part of the content-type we want would be to split on the semicolon and take the first element returned:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:content-type</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; "TEXT/PLAIN; charset=ISO-8859-1"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="p">(</span><span class="no">:content-type</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">))</span><span class="w"> </span><span class="o">#</span><span class="s">"[;]"</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; ["TEXT/PLAIN" " charset=ISO-8859-1"]</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="p">(</span><span class="no">:content-type</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">))</span><span class="w"> </span><span class="o">#</span><span class="s">"[;]"</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; "TEXT/PLAIN"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/lower-case</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="p">(</span><span class="no">:content-type</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">))</span><span class="w"> </span><span class="o">#</span><span class="s">"[;]"</span><span class="p">)))</span><span class="w">
</span><span class="c1">;=&gt; "text/plain"</span><span class="w">

</span><span class="c1">;; of course, we can use the thread-first macro again</span><span class="w">
</span><span class="c1">;; to stop building up nested calls</span><span class="w">

</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">my-bodies</span><span class="w">
          </span><span class="p">(</span><span class="nb">first</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="no">:content-type</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="o">#</span><span class="s">"[;]"</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nb">first</span><span class="p">)</span><span class="w">
          </span><span class="p">(</span><span class="nf">clojure.string/lower-case</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; "text/plain"</span><span class="w">
</span></code></pre></div></div>

<p>This leads us to a function to first clean up the content-type string, and then our predicate function to detect if it is the one we want. In <code class="language-plaintext highlighter-rouge">core.clj</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">simple-content-type</span><span class="w"> </span><span class="p">[</span><span class="n">full-content-type</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">-&gt;</span><span class="w"> </span><span class="n">full-content-type</span><span class="w">
      </span><span class="p">(</span><span class="nf">clojure.string/split</span><span class="w"> </span><span class="o">#</span><span class="s">"[;]"</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nb">first</span><span class="p">)</span><span class="w">
      </span><span class="p">(</span><span class="nf">clojure.string/lower-case</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">is-content-type?</span><span class="w"> </span><span class="p">[</span><span class="n">body</span><span class="w"> </span><span class="n">requested-type</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">=</span><span class="w"> </span><span class="p">(</span><span class="nf">simple-content-type</span><span class="w"> </span><span class="p">(</span><span class="no">:content-type</span><span class="w"> </span><span class="n">body</span><span class="p">))</span><span class="w">
     </span><span class="n">requested-type</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>To finish off our work on the message bodies, we want to filter the list returned by <code class="language-plaintext highlighter-rouge">message/message-body</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">is-content-type?</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">)</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; ({:content-type "TEXT/PLAIN; charset=ISO-8859-1", :body "Body\r\n"})</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">is-content-type?</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">)</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; {:content-type "TEXT/PLAIN; charset=ISO-8859-1", :body "Body\r\n"}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">is-content-type?</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">)</span><span class="w"> </span><span class="n">my-bodies</span><span class="p">)))</span><span class="w">
</span><span class="c1">;=&gt; "Body\r\n"</span><span class="w">
</span></code></pre></div></div>

<p>And turn it into a function that works for any message bodies list. In <code class="language-plaintext highlighter-rouge">core.clj</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">find-body-of-type</span><span class="w"> </span><span class="p">[</span><span class="n">bodies</span><span class="w"> </span><span class="n">type</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="no">:body</span><span class="w"> </span><span class="p">(</span><span class="nb">first</span><span class="w"> </span><span class="p">(</span><span class="nb">filter</span><span class="w"> </span><span class="o">#</span><span class="p">(</span><span class="nf">is-content-type?</span><span class="w"> </span><span class="n">%1</span><span class="w"> </span><span class="n">type</span><span class="p">)</span><span class="w"> </span><span class="n">bodies</span><span class="p">))))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-text-body</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">find-body-of-type</span><span class="w"> </span><span class="p">(</span><span class="nf">message/message-body</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="s">"text/plain"</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-html-body</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">find-body-of-type</span><span class="w"> </span><span class="p">(</span><span class="nf">message/message-body</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w"> </span><span class="s">"text/html"</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Note that we’ve also used this function to create two convenience functions, one for extracting plaintext bodies and one for extracting HTML bodies. By keeping functions simple and small, we can build up useful functions for our project rather than try to plan it all out ahead of time.</p>

<h2 id="getting-more-information-out-of-the-imapmessages">Getting more information out of the IMAPMessages</h2>

<p>As noted above, we will need to write a few more functions to get the fields of the <code class="language-plaintext highlighter-rouge">IMAPMessage</code>s that we cannot get through this version of <code class="language-plaintext highlighter-rouge">clojure-mail</code>. Recall that we want to get CC list, BCC list, date sent, and date received values. To do that, we will use Java interop functionality. It’s really not as bad as it sounds. Remember that the <code class="language-plaintext highlighter-rouge">IMAPMessage</code>s we see are Java instances of the <code class="language-plaintext highlighter-rouge">IMAPMessage</code> class. Calling a method on an instance is accomplished by using a dot before the method name, with the method in the function position, such as: <code class="language-plaintext highlighter-rouge">(.javaMethod some-java-instance)</code></p>

<p>To start, we can look at <code class="language-plaintext highlighter-rouge">clojure-mail</code>’s <a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/project.clj">project.clj</a> and see that it depends on <code class="language-plaintext highlighter-rouge">javax.mail</code>. The next step is to find the documentation for the Java implementation of <code class="language-plaintext highlighter-rouge">javax.mail.Message</code>, which <a href="http://docs.oracle.com/javaee/6/api/javax/mail/Message.html">lives here</a>.</p>

<p>In the REPL, we can try some of the Java interop on our <code class="language-plaintext highlighter-rouge">my-msg</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="n">my-msg</span><span class="w">
</span><span class="c1">;=&gt; #&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@eeb0450&gt;</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">.getSentDate</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; #inst "2014-03-28T16:35:22.000-00:00"</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">.getReceivedDate</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; #inst "2014-03-28T16:35:42.000-00:00"</span><span class="w">
</span></code></pre></div></div>

<p>The datetimes for each message are automatically converted from Java <code class="language-plaintext highlighter-rouge">Date</code>s into Clojure instants (timestamps) for us, which is convenient. If we dig into how the <code class="language-plaintext highlighter-rouge">clojure-mail.message/to</code> function [<a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/src/clojure_mail/message.clj#L16-L20">src</a>] works, we see that it is using the <code class="language-plaintext highlighter-rouge">.getRecipients</code> method. <code class="language-plaintext highlighter-rouge">.getRecipients</code> takes the message and a constant of a <code class="language-plaintext highlighter-rouge">RecipientType</code>. For our purposes, we want the <code class="language-plaintext highlighter-rouge">javax.mail.Message$RecipientType/CC</code> and <code class="language-plaintext highlighter-rouge">javax.mail.Message$RecipientType/BCC</code> recipients:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">.getRecipients</span><span class="w"> </span><span class="n">my-msg</span><span class="w"> </span><span class="n">javax.mail.Message$RecipientType/CC</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; #&lt;InternetAddress[] [Ljavax.mail.internet.InternetAddress;@f9d085d&gt;</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">.getRecipients</span><span class="w"> </span><span class="n">my-msg</span><span class="w"> </span><span class="n">javax.mail.Message$RecipientType/BCC</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w"> </span><span class="p">(</span><span class="nf">.getRecipients</span><span class="w"> </span><span class="n">my-msg</span><span class="w"> </span><span class="n">javax.mail.Message$RecipientType/CC</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; ("matt@bendyworks.com")</span><span class="w">
</span></code></pre></div></div>

<p>The last line maps the <code class="language-plaintext highlighter-rouge">str</code> function across each element returned, so that we get the string representation of the email addresses. That way, our database can just store the strings.</p>

<p>As before, now that we know how to use these methods in the REPL, we write functions in <code class="language-plaintext highlighter-rouge">core.clj</code> to take advantage of our newfound knowledge:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-sent-date</span><span class="w">
  </span><span class="s">"Returns an instant for the date sent"</span><span class="w">
  </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.getSentDate</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">get-received-date</span><span class="w">
  </span><span class="s">"Returns an instant for the date sent"</span><span class="w">
  </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nf">.getReceivedDate</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">cc-list</span><span class="w">
  </span><span class="s">"Returns a sequence of CC-ed recipients"</span><span class="w">
  </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w">
    </span><span class="p">(</span><span class="nf">.getRecipients</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="n">javax.mail.Message$RecipientType/CC</span><span class="p">)))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">bcc-list</span><span class="w">
  </span><span class="s">"Returns a sequence of BCC-ed recipients"</span><span class="w">
  </span><span class="p">[</span><span class="n">msg</span><span class="p">]</span><span class="w">
  </span><span class="p">(</span><span class="nb">map</span><span class="w"> </span><span class="nb">str</span><span class="w">
    </span><span class="p">(</span><span class="nf">.getRecipients</span><span class="w"> </span><span class="n">msg</span><span class="w"> </span><span class="n">javax.mail.Message$RecipientType/BCC</span><span class="p">)))</span><span class="w">
</span></code></pre></div></div>

<p>In the REPL, it should now be possible to get a nice map representation of all the fields on the message we care about:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="n">my-msg</span><span class="w">
</span><span class="c1">;=&gt; #&lt;IMAPMessage com.sun.mail.imap.IMAPMessage@eeb0450&gt;</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">{</span><span class="no">:mail/uid</span><span class="w"> </span><span class="p">(</span><span class="nf">remove-angle-brackets</span><span class="w"> </span><span class="p">(</span><span class="nf">message/id</span><span class="w"> </span><span class="n">my-msg</span><span class="p">))</span><span class="w">
 </span><span class="no">:mail/from</span><span class="w"> </span><span class="p">(</span><span class="nf">message/from</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/to</span><span class="w"> </span><span class="p">(</span><span class="nf">message/to</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/cc</span><span class="w"> </span><span class="p">(</span><span class="nf">cc-list</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/bcc</span><span class="w"> </span><span class="p">(</span><span class="nf">bcc-list</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/subject</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/date-sent</span><span class="w"> </span><span class="p">(</span><span class="nf">get-sent-date</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/date-received</span><span class="w"> </span><span class="p">(</span><span class="nf">get-received-date</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/text-body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-text-body</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)</span><span class="w">
 </span><span class="no">:mail/html-body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-html-body</span><span class="w"> </span><span class="n">my-msg</span><span class="p">)}</span><span class="w">
</span><span class="c1">;=&gt; {:mail/cc ("matt@bendyworks.com"), :mail/from "Matt Gauger &lt;contact@mattgauger.com&gt;", :mail/date-sent #inst "2014-03-28T16:35:22.000-00:00", :mail/uid "CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com", :mail/to ("contact@mattgauger.com"), :mail/html-body "&lt;div dir=\"ltr\"&gt;Body&lt;/div&gt;\r\n", :mail/subject "With Matt@Bendyworks in CC", :mail/date-received #inst "2014-03-28T16:35:42.000-00:00", :mail/bcc (), :mail/text-body "Body\r\n"}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">clojure.pprint/pprint</span><span class="w"> </span><span class="n">*1</span><span class="p">)</span><span class="w">
</span><span class="p">{</span><span class="no">:mail/cc</span><span class="w"> </span><span class="p">(</span><span class="s">"matt@bendyworks.com"</span><span class="p">)</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/from</span><span class="w"> </span><span class="s">"Matt Gauger &lt;contact@mattgauger.com&gt;"</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/date-sent</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2014-03-28T16:35:22.000-00:00"</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/uid</span><span class="w">
 </span><span class="s">"CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com"</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/to</span><span class="w"> </span><span class="p">(</span><span class="s">"contact@mattgauger.com"</span><span class="p">)</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/html-body</span><span class="w"> </span><span class="s">"&lt;div dir=\"ltr\"&gt;Body&lt;/div&gt;\r\n"</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/subject</span><span class="w"> </span><span class="s">"Testing 3"</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/date-received</span><span class="w"> </span><span class="o">#</span><span class="n">inst</span><span class="w"> </span><span class="s">"2014-03-28T16:35:42.000-00:00"</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/bcc</span><span class="w"> </span><span class="p">()</span><span class="n">,</span><span class="w">
 </span><span class="no">:mail/text-body</span><span class="w"> </span><span class="s">"Body\r\n"</span><span class="p">}</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span></code></pre></div></div>

<p>Congratulations on making it this far. We’ve used quite a few neat little features of Clojure and the libraries we’re building this project with to get here.</p>

<p>The last step we’ll go through in this post is to get these messages into a database.</p>

<h2 id="enter-datomic-the-immutable-datastore">Enter Datomic, the immutable datastore</h2>

<p><a href="http://www.datomic.com/">Datomic</a> is a great database layer built on Clojure that gives us a database value representing immutable data. New transactions on the database create new database values. It fits very well with Clojure’s own concept of <a href="http://clojure.org/state">state and identity</a> because it was designed by the same folks as Clojure. Plus, Datomic is meant to grow and scale in modern environments like AWS, with many backend datastore options to run it on.</p>

<p>There’s some important reasons why you might choose Datomic as your database for a data science / machine learning application:</p>

<ul>
  <li>There are various storage backends, so you can grow from tens of thousands of rows in PostgreSQL on a developer’s laptop to millions of records (or more) in Riak or DynamoDB on AWS. That is, it has a good migration path from small datasets to big data through the Datomic import/export process</li>
  <li>The concept of time associated with each value in Datomic means that we can query for historical data to compare against</li>
  <li>Datomic has a lightweight schema compared to a relational database like PostgreSQL. Schemas are just data! When we begin computing new values from our dataset, we can add new types of entities easily at the same time.</li>
  <li>Datomic’s schemas allow us to treat it as a key-value store, relational database, or even build a graph store on top of it, if we need to</li>
</ul>

<p><strong>Note</strong>: I won’t go through setting up an entire Datomic installation here. It’s worth reading up on the <a href="http://docs.datomic.com/">docs</a> and the <a href="http://www.datomic.com/rationale.html">rationale</a> behind Datomic’s design.</p>

<p>You can get the <a href="https://my.datomic.com/downloads/free">Datomic free build</a> if you like, but you will be limited to in-memory stores. It is unlikely that your Gmail inbox will fit into memory on your dev machine. Instead, I recommend signing up for the free <a href="http://www.datomic.com/get-datomic.html">Datomic Pro Starter Edition</a>. (The free Starter Edition is fine because you will not be using this project in a commercial capacity.) Once you have Datomic Pro downloaded and installed in your local Maven, I recommend using the PostgreSQL storage adapter locally with memcached. Follow the guides for configuring storage on the <a href="http://docs.datomic.com/storage.html">Datomic Storage</a> page.</p>

<p>Add the correct line to your <code class="language-plaintext highlighter-rouge">project.clj</code> dependencies for the version of Datomic you’ll be using (mine was <code class="language-plaintext highlighter-rouge">[com.datomic/datomic-pro "0.9.4384"]</code> which might be a bit out of date and likely won’t match yours.) Now we can start using Datomic in our <code class="language-plaintext highlighter-rouge">core.clj</code> and our REPL.</p>

<p>The first thing we need is the URI where the Datomic database lives. When we start up the Datomic transactor, you will see a DB URI that looks something like <code class="language-plaintext highlighter-rouge">datomic:sql://DBNAMEHERE?jdbc:postgresql://localhost:5432/datomic?user=datomic&amp;password=datomic</code> in the output. Grab that URI and add it to our <code class="language-plaintext highlighter-rouge">resources/config/autodjinn-config.edn</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="no">:gmail-username</span><span class="w"> </span><span class="s">"you@gmail.com"</span><span class="w">
 </span><span class="no">:gmail-password</span><span class="w"> </span><span class="s">"yourpassword"</span><span class="w">
 </span><span class="no">:db-uri</span><span class="w"> </span><span class="s">"datomic:sql://DBNAMEHERE?jdbc:postgresql://localhost:5432/datomic?user=datomic&amp;password=datomic"</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Back at the top of <code class="language-plaintext highlighter-rouge">core.clj</code>, save that value to a var as we did with <code class="language-plaintext highlighter-rouge">gmail-username</code> and <code class="language-plaintext highlighter-rouge">gmail-password</code>:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-uri</span><span class="w"> </span><span class="p">(</span><span class="nb">get</span><span class="w"> </span><span class="p">(</span><span class="nf">mail-config</span><span class="p">)</span><span class="w"> </span><span class="no">:db-uri</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>And then in the REPL:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">require</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="n">datomic.api</span><span class="w"> </span><span class="no">:as</span><span class="w"> </span><span class="n">d</span><span class="p">])</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/create-database</span><span class="w"> </span><span class="n">db-uri</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; true</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/create-database</span><span class="w"> </span><span class="n">db-uri</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; false</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-connection</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="n">db-uri</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #'user/db-connection</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/db</span><span class="w"> </span><span class="n">db-connection</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; datomic.db.Db@8472447a</span><span class="w">
</span></code></pre></div></div>

<p>Note that according to the <a href="http://docs.datomic.com/clojure/index.html#datomic.api/create-database">datomic clojure docs for the create-database function</a>, it returns true if the database was created, and false if it already exists. So running <code class="language-plaintext highlighter-rouge">create-database</code> every time we run our script is safe, since it won’t destroy data.</p>

<p>If the above work in the REPL doesn’t work, it is likely your code is unable to talk to your running Datomic, or your Datomic transactor is not configured correctly. Diagnose it with Googling and reading the docs until you get it to work, then move on.</p>

<p>Calling <code class="language-plaintext highlighter-rouge">(d/db db-connection)</code> gives us the current value of our database. In most cases, we want to just get the most current value. So, we can write a convenience function <code class="language-plaintext highlighter-rouge">new-db-val</code> to always get us the current (and possibly different) database value. But there are cases where we want to coordinate several queries and use the same database values for each. In those cases, we won’t use the function get the latest database value, but rather pass this database value to the queries so that all query against the same state.</p>

<p>In our <code class="language-plaintext highlighter-rouge">core.clj</code>, we can add the code we need to create the database, get our connection, and the convenience <code class="language-plaintext highlighter-rouge">new-db-val</code> function:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">;; Always try to create the database</span><span class="w">
</span><span class="p">(</span><span class="nf">d/create-database</span><span class="w"> </span><span class="n">db-uri</span><span class="p">)</span><span class="w">

</span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">db-connection</span><span class="w"> </span><span class="p">(</span><span class="nf">d/connect</span><span class="w"> </span><span class="n">db-uri</span><span class="p">))</span><span class="w">

</span><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">new-db-val</span><span class="w"> </span><span class="p">[]</span><span class="w"> </span><span class="p">(</span><span class="nf">d/db</span><span class="w"> </span><span class="n">db-connection</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Next, we need to tell Datomic about the schema of our data. Schemas are just data that you run as a transaction on the database. Reading up on the <a href="http://docs.datomic.com/schema.html">Schema</a> page of the Datomic docs might be helpful to understand what’s going on here. The short version is that we define each attribute of an email and set up its properties. The collection of all attributes together will constitute a <code class="language-plaintext highlighter-rouge">mail</code> entity, so we namespace all the attributes under the <code class="language-plaintext highlighter-rouge">:mail/</code> namespace.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">schema-txn</span><span class="w">
  </span><span class="p">[{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/uid</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db/unique</span><span class="w"> </span><span class="no">:db.unique/identity</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/to</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/many</span><span class="w">
    </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/cc</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/many</span><span class="w">
    </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/bcc</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/many</span><span class="w">
    </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/from</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/subject</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/date-sent</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/instant</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/date-received</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/instant</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/text-body</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/fulltext</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/index</span><span class="w"> </span><span class="n">true</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}</span><span class="w">
   </span><span class="p">{</span><span class="no">:db/id</span><span class="w"> </span><span class="o">#</span><span class="n">db/id</span><span class="p">[</span><span class="no">:db.part/db</span><span class="p">]</span><span class="w">
    </span><span class="no">:db/ident</span><span class="w"> </span><span class="no">:mail/html-body</span><span class="w">
    </span><span class="no">:db/valueType</span><span class="w"> </span><span class="no">:db.type/string</span><span class="w">
    </span><span class="no">:db/cardinality</span><span class="w"> </span><span class="no">:db.cardinality/one</span><span class="w">
    </span><span class="no">:db.install/_attribute</span><span class="w"> </span><span class="no">:db.part/db</span><span class="p">}])</span><span class="w">
</span></code></pre></div></div>

<p>We add that var def to our <code class="language-plaintext highlighter-rouge">core.clj</code> because it is, after all, just data. We may choose later to move it to its own <code class="language-plaintext highlighter-rouge">edn</code> file, but for now, it can live in our source code. Next, we want to apply this schema to our database with a transaction. That looks like this:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="n">schema-txn</span><span class="w">
</span><span class="c1">;=&gt; [{:db/cardinality :db.cardinality/one, …}]</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">db-connection</span><span class="w"> </span><span class="n">schema-txn</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; #&lt;promise$settable_future$reify__4427@5ede7c85: {:db-before datomic.db.Db@8472447a, :db-after datomic.db.Db@f8962e84, :tx-data [#Datum{:e 13194139534322 :a 50 :v #inst "2014-03-30T20:37:53.113-00:00" :tx 13194139534322 :added true} #Datum{:e 77 :a 41 :v 36 :tx 13194139534322 :added true} #Datum{:e 77 :a 44 :v true :tx 13194139534322 :added true} #Datum{:e 77 :a 51 :v true :tx 13194139534322 :added true} #Datum{:e 77 :a 40 :v 23 :tx 13194139534322 :added true} #Datum{:e 77 :a 10 :v :mail/bcc :tx 13194139534322 :added true} #Datum{:e 0 :a 13 :v 77 :tx 13194139534322 :added true}], :tempids {-9223367638809264705 64, -9223367638809264706 73, -9223367638809264707 77, -9223367638809264708 65, -9223367638809264709 66, -9223367638809264710 67, -9223367638809264711 68, -9223367638809264712 69, -9223367638809264713 70, -9223367638809264704 63}}&gt;</span><span class="w">
</span></code></pre></div></div>

<p>Now we put that transaction in a convenience function in <code class="language-plaintext highlighter-rouge">core.clj</code> that we’ll run every time we run this file. The function will ensure that our database is ‘converged’ to this schema. Running a transaction will create a new database value. But it will not blow away any data that we had in the database by running this transaction many times. It will simply try to update the existing attributes, and nothing in the attributes themselves need change. It is far more work to retract (delete) data in Datomic than it is to add or update it. This leads to much more safety around working with data without worrying that we will destroy data, and it encourages a REPL-based exploration of the data and its history.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">update-schema</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">db-connection</span><span class="w"> </span><span class="n">schema-txn</span><span class="p">))</span><span class="w">
</span></code></pre></div></div>

<p>Now that our <code class="language-plaintext highlighter-rouge">mail</code> entities are defined in Datomic, we can try a query to find all the entity-IDs where any <code class="language-plaintext highlighter-rouge">:mail/uid</code> value is present. Read up on the <a href="http://docs.datomic.com/query.html">Query</a> page of the Datomic docs to dig into querying deeper. You might also be interested in the excellent <a href="http://www.learndatalogtoday.org/">Learn Datalog Today</a> website to learn more about querying Datomic with Datalog.</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?eid</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?eid</span><span class="w"> </span><span class="no">:mail/uid</span><span class="w"> </span><span class="n">_</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">new-db-val</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #{}</span><span class="w">
</span></code></pre></div></div>

<p>Since we have no <code class="language-plaintext highlighter-rouge">mail</code> entities in our database, Datomic returns an empty set. So now we reach the end of task: We can ingest some emails and save them in our database! Return to the <code class="language-plaintext highlighter-rouge">ingest-inbox</code> function that we left before. Here’s what the updated version will look like:</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">defn</span><span class="w"> </span><span class="n">ingest-inbox</span><span class="w"> </span><span class="p">[]</span><span class="w">
  </span><span class="p">(</span><span class="nb">doseq</span><span class="w"> </span><span class="p">[</span><span class="n">msg</span><span class="w"> </span><span class="p">(</span><span class="nf">inbox</span><span class="w"> </span><span class="n">my-store</span><span class="p">)]</span><span class="w">
    </span><span class="p">(</span><span class="nb">println</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span><span class="w">
    </span><span class="o">@</span><span class="p">(</span><span class="nf">d/transact</span><span class="w"> </span><span class="n">db-connection</span><span class="w"> </span><span class="p">[{</span><span class="no">:db/id</span><span class="w"> </span><span class="p">(</span><span class="nf">d/tempid</span><span class="w"> </span><span class="s">"db.part/user"</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/uid</span><span class="w"> </span><span class="p">(</span><span class="nf">remove-angle-brackets</span><span class="w"> </span><span class="p">(</span><span class="nf">message/id</span><span class="w"> </span><span class="n">msg</span><span class="p">))</span><span class="w">
                                 </span><span class="no">:mail/from</span><span class="w"> </span><span class="p">(</span><span class="nf">message/from</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/to</span><span class="w"> </span><span class="p">(</span><span class="nf">message/to</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/cc</span><span class="w"> </span><span class="p">(</span><span class="nf">cc-list</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/bcc</span><span class="w"> </span><span class="p">(</span><span class="nf">bcc-list</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/subject</span><span class="w"> </span><span class="p">(</span><span class="nf">message/subject</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/date-sent</span><span class="w"> </span><span class="p">(</span><span class="nf">get-sent-date</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/date-received</span><span class="w"> </span><span class="p">(</span><span class="nf">get-received-date</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/text-body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-text-body</span><span class="w"> </span><span class="n">msg</span><span class="p">)</span><span class="w">
                                 </span><span class="no">:mail/html-body</span><span class="w"> </span><span class="p">(</span><span class="nf">get-html-body</span><span class="w"> </span><span class="n">msg</span><span class="p">)}])))</span><span class="w">
</span></code></pre></div></div>

<p>We use the <code class="language-plaintext highlighter-rouge">@</code>-sign before the <code class="language-plaintext highlighter-rouge">(d/transact…)</code> call because Datomic normally returns a promise of the completed transaction. However, we want to force Datomic to complete each transaction before moving on by deref-ing it with the <code class="language-plaintext highlighter-rouge">@</code>-sign. Per the Clojure docs: “Calls to deref/@ prior to delivery will block.”</p>

<p>If you run this function in your REPL, you should see it start to ingest your email from Gmail!</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">autodjinn.core/ingest-inbox</span><span class="p">)</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">3</span><span class="w">
</span><span class="n">Testing!</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">2</span><span class="w">
</span><span class="n">Subject</span><span class="w"> </span><span class="mi">1</span><span class="w">
</span><span class="c1">;=&gt; nil</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?eid</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?eid</span><span class="w"> </span><span class="no">:mail/uid</span><span class="w"> </span><span class="n">_</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">new-db-val</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; #{[17592186045419] [17592186045421] [17592186045423] [17592186045425]}</span><span class="w">
</span></code></pre></div></div>

<p>Note that this could a take a <strong>long time</strong> if you’ve chosen to import a really large Gmail inbox! You might want to stop the import at some point; in most REPLs <code class="language-plaintext highlighter-rouge">Ctrl-c</code> will stop the running function.</p>

<p>If we query for our entity-IDs again, as above, we should see some values returned!</p>

<p>What does one of those database entities look like when we run it through Datomic’s <a href="http://docs.datomic.com/clojure/index.html#datomic.api/entity">entity</a> and <a href="http://docs.datomic.com/clojure/index.html#datomic.api/touch">touch</a> functions to instantiate all its attributes?</p>

<div class="language-clojure highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="k">def</span><span class="w"> </span><span class="n">my-mail</span><span class="w"> </span><span class="p">(</span><span class="nb">ffirst</span><span class="w"> </span><span class="p">(</span><span class="nf">d/q</span><span class="w"> </span><span class="o">'</span><span class="p">[</span><span class="no">:find</span><span class="w"> </span><span class="n">?eid</span><span class="w"> </span><span class="no">:where</span><span class="w"> </span><span class="p">[</span><span class="n">?eid</span><span class="w"> </span><span class="no">:mail/uid</span><span class="w"> </span><span class="n">_</span><span class="p">]]</span><span class="w"> </span><span class="p">(</span><span class="nf">new-db-val</span><span class="p">))))</span><span class="w">
</span><span class="c1">;=&gt; #'user/my-mail</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="n">my-mail</span><span class="w">
</span><span class="c1">;=&gt; 17592186045419</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entity</span><span class="w"> </span><span class="p">(</span><span class="nf">new-db-val</span><span class="p">)</span><span class="w"> </span><span class="n">my-mail</span><span class="p">)</span><span class="w">
</span><span class="c1">;=&gt; {:db/id 17592186045419}</span><span class="w">
</span><span class="n">user&gt;</span><span class="w"> </span><span class="p">(</span><span class="nf">d/touch</span><span class="w"> </span><span class="p">(</span><span class="nf">d/entity</span><span class="w"> </span><span class="p">(</span><span class="nf">new-db-val</span><span class="p">)</span><span class="w"> </span><span class="n">my-mail</span><span class="p">))</span><span class="w">
</span><span class="c1">;=&gt; {:mail/cc #{"matt@bendyworks.com"}, :mail/from "Matt Gauger &lt;contact@mattgauger.com&gt;", :mail/date-sent #inst "2014-03-28T16:35:22.000-00:00", :mail/uid "CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com", :mail/to #{"contact@mattgauger.com"}, :mail/html-body "&lt;div dir=\"ltr\"&gt;Body&lt;/div&gt;\r\n", :mail/subject "With Matt@Bendyworks in CC", :mail/date-received #inst "2014-03-28T16:35:42.000-00:00", :mail/text-body "Body\r\n", :db/id 17592186045419}</span><span class="w">
</span></code></pre></div></div>

<h2 id="wrapping-up">Wrapping up</h2>

<p>That’s it for this blog post. It took a little setup, but we were able to build up a working Gmail import tool with help from our REPL and some nice Clojure libraries.</p>

<p>Next time, we’ll be looking at doing some basic querying of the data, including getting a count of the number of times each email address has sent you an email.</p>

<p>Comments? Questions? Feel free to contact me at <a href="mailto:contact@mattgauger.com">contact@mattgauger.com</a>. I’d love to hear from you.</p>

<hr />

<p><a name="cds-gmail-footnote-1"></a>
<strong>1</strong> In this case, machine learning <em>features</em>, which are the input variables for our learning tasks. Not software features that we a client might ask us to implement. See: <a href="https://en.wikipedia.org/wiki/Feature_learning">Feature learning - Wikipedia, the free encyclopedia</a>.
<a href="#cds-gmail-footnote-1-return">↩</a></p>



</div>

<div class="pagination">

  <a href="/2014/04/13/clojure-data-science-refactoring-and-cleanup/" class="left arrow">&#8592;</a>


  <a href="/2014/03/20/a-quick-dashboard-in-hoplon-and-castra/" class="right arrow">&#8594;</a>


  <a href="#" class="top">Top</a>
</div>

    </main>

    <footer>
      <span>
        &copy; <time datetime="2022">2022</time> Matt Gauger.
      </span>
      <a rel="me" href="https://mastodon.xyz/@mathiasx">@mathiasx@mastodon.xyz</a>
    </footer>
  </body>
</html>
