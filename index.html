
<!DOCTYPE HTML>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>blog.mattgauger.com</title>
    <meta name="author" content="Matt Gauger">

    
    <meta name="description" content="Housekeeping: Imported Coderwall Protips As part of my continuing effort to archive content I&#8217;ve created to this blog, I&#8217;ve migrated all &hellip;">
    

    <link href="/atom.xml" rel="alternate" title="blog.mattgauger.com" type="application/atom+xml">
    <link rel="canonical" href="">
    <link href="/favicon.ico" rel="shortcut icon">
    <link href="/stylesheets/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <!-- Le HTML5 shim, for IE6-8 support of HTML5 elements -->
    <!--[if lt IE 9]>
      <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
</head>


<body>
  <header class="inner"><div class="navbar">
  <div class="navbar-inner">
    <div class="container">
      <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </a>

      <a href="/" class="brand">blog.mattgauger.com</a>

      <div class="nav-collapse">
        <nav class="menu left"><ul class="nav">
  <li><a href="/about">About</a></li>
  <li><a href="/blog/archives">Blog Archives</a></li>
  <li><a href="/presentations">Presentations</a></li>
  
  <li class="divider-vertical"></li>
  <li><a class="feed" href="http://feeds.feedburner.com/MattGaugerBlog" title="Atom XML/RSS Feed">Atom Feed</a></li>
  
</ul>
</nav>
        <div class="right">
          <form class="navbar-search pull-right" action="http://google.com/search" method="get">
            <input class="input-medium search-query span2" type="text" name="q" results="0" placeholder="Search">
            <input type="hidden" name="q" value="site:blog.mattgauger.com">
          </form>
        </div>
      </div>
    </div>
  </div>
</div>
</header>
  <div class="container bottom-left-rounded-corner bottom-right-rounded-corner" id="page-container">
    <div class="row">
  <article class="page span8 offset2">
    
    


  <article class="post">
    
    <h1 class="title"><a href="/blog/2014/07/27/housekeeping-imported-coderwall-protips/">Housekeeping: Imported Coderwall Protips</a></h1>
    <div class="entry">
        <p>As part of my continuing effort to archive content I&#8217;ve created to this blog, I&#8217;ve migrated all of <a href="https://coderwall.com/p/u/mathias">my Coderwall protips</a>.</p>

<p>Here&#8217;s a quick list of the posts:</p>

<ul>
<li><a href="http://blog.mattgauger.com/blog/2013/11/14/indent-and-colorize-html-strings-in-pry/">Indent and Colorize HTML Strings in Pry</a> <em>November 14, 2013.</em></li>
<li><a href="http://blog.mattgauger.com/blog/2013/09/03/git-fml/">git fml</a> <em>September 3, 2013.</em></li>
<li><a href="http://blog.mattgauger.com/blog/2013/07/27/minskys-circle-algorithm-in-shoes-dot-rb-slash-hackety-hack/">Minsky&#8217;s Circle Algorithm in Shoes.rb / Hackety Hack</a> <em>July 27, 2013.</em></li>
<li><a href="http://blog.mattgauger.com/blog/2013/05/23/warning-nokogiri-was-built-against-libxml-version-x-dot-x-x/">WARNING: Nokogiri Was Built Against LibXML Version x.x.x</a> <em>May 23, 2013.</em></li>
<li><a href="http://blog.mattgauger.com/blog/2013/04/24/reset-a-lost-password-on-an-ubuntu-vm/">Reset a Lost Password on an Ubuntu VM</a> <em>April 24, 2013.</em></li>
<li><a href="http://blog.mattgauger.com/blog/2013/01/24/find-naughty-naughty-model-calls-in-your-views/">Find Naughty Naughty Model Calls in Your Views</a> <em>January 24, 2013.</em></li>
<li><a href="http://blog.mattgauger.com/blog/2012/12/25/find-a-unique-name-for-your-project/">Find a Unique Name for Your Project</a> <em>December 25, 2012.</em></li>
</ul>


        
        
    </div>

    <div class="meta">
        <div class="author">
  

<span class="byline author vcard">Posted by <span class="fn">Matt Gauger</span>.</span>
</div>
        <div class="date">












<time datetime="2014-07-27T12:05:00-05:00" pubdate  data-updated="true" >Jul 27<span>th</span>, 2014</time>.</div>
        <div class="tags">

</div>
    </div>

  </article>


  <article class="post">
    
    <h1 class="title"><a href="/blog/2014/04/13/clojure-data-science-refactoring-and-cleanup/">Clojure Data Science: Refactoring and Cleanup</a></h1>
    <div class="entry">
        <hr />

<p>This is Part 2 of a series of blog posts called <a href="/blog/categories/clojure-data-science">Clojure Data Science</a>. Check out the <a href="/blog/2014/03/30/clojure-data-science-ingesting-your-gmail-inbox/">previous post</a> if you missed it.</p>

<hr />

<p>Welcome to the second post in this series. If you followed along in the last post, your code should be ready to use in this post. If not, or if you need to go back to known working state, you can clone the <a href="https://github.com/mathias/autodjinn">autodjinn repo</a> and <code>git checkout v0.1.0</code>.</p>

<p>I started out writing this post to develop simple functionality on our inbox data. Finishing the post was taking longer than I was expecting, so I split the post in half in the interest of posting this sooner.</p>

<p>In this post, we need to create an email ingestion script that we can run repeatedly with <code>lein</code>. And we need to talk about refactoring our code out into maintainable namespaces.</p>

<p>So make sure your Datomic transactor is running and launch a REPL, because it is time to give our code a makeover.</p>

<h2>A Gmail ingestion script</h2>

<p>Because Clojure sits on the JVM, it shares some similarities with Java. One of these is the special purpose of a <code>-main</code> function. You can think of this as the <code>main</code> method in a Java class. The <code>-main</code> function in a Clojure namespace will be run when a tool like <code>lein</code> tries to &#8220;run&#8221; the namespace. That sounds like exactly what we want to do with our Gmail import functionality, so we will add a <code>-main</code> function that calls our <code>ingest-inbox</code> function. To get started, we will only have it print us a message.</p>

<script src="https://gist.github.com/mathias/9965864.js"></script>


<p>You can then run this by invoking <code>lein run -m autodjinn.core</code>. You should see <code>Hello world!</code> if everything worked. You may notice that the process doesn&#8217;t seem to quit after it prints the hello world message &#8211; this seems to be problem with Leiningen. To ensure that our process ends when the script is done, we can add a <code>(System/exit 0)</code> line to the end of our <code>-main</code> function to ensure that the process quits normally. On *nix systems, a 0 return code means successful exit, and a nonzero response code means something went wrong. Knowing this, we can take advantage of response codes in the future to signal that an error occurred in our script. But for now, we will have the script end by returning 0 to indicate a successful exit.</p>

<p>Think back to what we did to ingest email in our REPL in the last post. We had to connect to the database, run the data schema transaction, and then we were able to run <code>ingest-inbox</code> to pull in our email.</p>

<p>The following function will do the same thing. Remember that things like trying to create an existing database or performing a schema update against the same schema in Datomic should be harmless. It will add a new transaction ID, but it will not modify or destroy data. Putting together all the steps we need to run, we get a <code>-main</code> function that looks like this:</p>

<script src="https://gist.github.com/mathias/9965933.js"></script>


<h2>Refactoring namespaces</h2>

<p>With Clojure, one must walk a fine line between putting all of your functions into one big file, and having too many namespaces. One big file quickly grows unmaintainable and gains too many responsibilities.</p>

<p>But having too many namespaces can also be a problem. It may create strange cyclic dependency errors. Or you may find that with many separate namespaces, you have to require many namespaces to get anything done.</p>

<p>To avoid this, I start with most code in one namespace, and then look for common functionality to extract to a new namespace. Good candidates to extract are those that all talk about the same business logic or business domain. You may notice that the responsibility for one group of functions is different than the rest of the functions. That is a good candidate for a new namespace. Looking at responsibilities can be a good way to determine where to break apart functions into namespaces.</p>

<p>In this project, we can identify two responsibilities that currently live in our autodjinn.core namespace. The first is working with the database. The second is ingesting Gmail messages. As our project grows, we will not want the code for ingesting Gmail messages to live in <code>autodjinn.core</code>. With that in mind, let&#8217;s create a new file called <code>src/autodjinn/gmail_ingestion.clj</code> and move over the vars and functions that we think should live there. That file should look like this:</p>

<script src="https://gist.github.com/mathias/9966207.js"></script>


<p>Be sure to remove the functions and vars that we moved to this file from the <code>autodjinn.core</code> namespace. Note that we moved the <code>-main</code> function here, too, so that we can now run <code>lein run -m autodjinn.gmail-ingestion</code></p>

<p>You may also notice that we still had to require the <code>datomic.api</code> namespace here to be able to perform a transaction. Our <code>autodjinn.core</code> namespace already handles database interaction, though. So let&#8217;s write a <code>create-mail</code> function in <code>core.clj</code> and call it in our new namespace:</p>

<script src="https://gist.github.com/mathias/9966294.js"></script>


<p>And in <code>gmail_ingestion.clj</code> we change <code>ingest-inbox</code> to use the new function. While we&#8217;re at it, we&#8217;ll break out a convenience function to prepare the attr map for Datomic:</p>

<script src="https://gist.github.com/mathias/9966304.js"></script>


<p>If we run our <code>lein run -m autodjinn.gmail-ingestion</code> command, we should see that the code is still working.</p>

<p>Don&#8217;t forget to remove the <code>datomic.api</code> requirement in <code>gmail-ingestion</code> namespace! Now we only need to require Datomic in the <code>autodjinn.core</code> namespace.</p>

<p>There&#8217;s one more low-hanging fruit that we can refactor about this code before moving on. The config file is loaded and used in both namespaces. We already require everything from <code>autodjinn.core</code> into <code>autodjinn.gmail-ingestion</code>. So we can safely change a few lines to use the config in <code>gmail_ingestion.clj</code> and stop requiring <code>nomad</code> in two places:</p>

<script src="https://gist.github.com/mathias/9966372.js"></script>


<p>And in <code>core.clj</code>:</p>

<script src="https://gist.github.com/mathias/9966384.js"></script>


<p>Running <code>lein run -m autodjinn.gmail-ingestion</code> one more time, we should see that our changes did not break the system. The config is now only loaded once, and we use it everything.</p>

<p>That&#8217;s it! We&#8217;ve taken care of some low-hanging fruit and are ready to implement some new functionality. If you want to compare what you&#8217;ve done with my version, you can run <code>git diff v0.1.1</code> on the <a href="https://github.com/mathias/autodjinn">autodjinn repo</a>.</p>

<p>Please let me know what you think of these posts by sending me an email at <a href="mailto:contact@mattgauger.com">contact@mattgauger.com</a>. I&#8217;d love to hear from you!</p>

        
        
    </div>

    <div class="meta">
        <div class="author">
  

<span class="byline author vcard">Posted by <span class="fn">Matt Gauger</span>.</span>
</div>
        <div class="date">












<time datetime="2014-04-13T16:28:00-05:00" pubdate  data-updated="true" >Apr 13<span>th</span>, 2014</time>.</div>
        <div class="tags">

</div>
    </div>

  </article>


  <article class="post">
    
    <h1 class="title"><a href="/blog/2014/03/30/clojure-data-science-ingesting-your-gmail-inbox/">Clojure Data Science: Ingesting Your Gmail Inbox</a></h1>
    <div class="entry">
        <hr />

<p>This is Part 1 of a series of blog posts inspired by the exercises from <a href="http://shop.oreilly.com/product/0636920025054.do">Agile Data Science</a> with Clojure. You may be interested in my <a href="http://blog.mattgauger.com/blog/2014/03/14/agile-data-science-review-and-thoughts/">review</a> of the book.</p>

<hr />

<p>For this blog post series, we are going to use your Gmail inbox as a dataset for an exploration of data science practices. Namely, we will use your email for machine learning and natural language processing applications. Email makes interesting data to process:</p>

<ul>
<li>it has lots of metadata that we can use as features <a href="#cds-gmail-footnote-1" name="cds-gmail-footnote-1-return">[1]</a></li>
<li>we can model the relationships of senders and receivers as a graph</li>
<li>each message has a body of text associated with it that we can analyze</li>
<li>gaining insights from our personal communication is far more interesting than using an open data set!</li>
</ul>


<p><strong>Note:</strong> This is not an intro-to-Clojure blog post. If you need a tutorial that starts with the basics, I recommend the <a href="http://aphyr.com/tags/Clojure-from-the-ground-up">Clojure from the ground up</a> blog post series by <a href="https://twitter.com/aphyr">Aphyr</a>. It does an excellent job at introducing concepts in Clojure.</p>

<p>In this post, I follow my typical Clojure workflow: I open a REPL and begin exploring the problem space. I look at individual pieces of data and start transforming them. When I write some functionality that I like for one piece of data, I try to extract it into the source code as a function that can work for any data our project may see. In this way, we can build up the project to contain the functions that are necessary to get to our goal.</p>

<p>So what is our goal for this blog post? Well, we want to fetch all emails from our Gmail inbox. We want to get metadata for each email, including things like who sent it and when it was sent. Then, we want to save the messages into a database so we can do further processing in later posts.</p>

<p>Starting off, make a new basic Clojure project with lein. I&#8217;ve named my project <a href="https://github.com/mathias/autodjinn">autodjinn</a> after <a href="http://en.wikipedia.org/wiki/Email#Origin">AUTODIN</a>, one of the first email networks. You can use the <a href="https://github.com/mathias/autodjinn">repo</a> to refer to and to clone to follow along. At the beginning of each subsequent post, I&#8217;ll provide a SHA that you can reset the code to. Feel free to name your project whatever you want; just be sure to pay attention to the changes in filenames and namespaces as we go along!</p>

<p>Create the project and enter it:</p>

<script src="https://gist.github.com/mathias/9861772.js"></script>


<p>To import our Gmail data, we will use a Clojure library called <a href="https://github.com/owainlewis/clojure-mail">clojure-mail</a>. Clojure-mail is still under active development and is likely to change. For this blog post, we&#8217;ll be using version <code>0.1.6</code> to ensure compatibility between the code in this post and the library.</p>

<p>Edit <code>project.clj</code> to contain your information and add the <code>[clojure-mail "0.1.6"]</code> dependency:</p>

<script src="https://gist.github.com/mathias/9861804.js"></script>


<p>We&#8217;ll start by working in <code>src/autodjinn/core.clj</code> and later move the functionality out into a script for our email import task. Open up the file in your favorite editor and launch a REPL.</p>

<p>In your REPL, <code>(use 'autodjinn.core)</code> and verify it worked by running <code>(foo "MYNAME")</code>. You should see &#8220;MYNAME Hello, World!&#8221; printed out. Feel free to remove the <code>(defn foo…)</code> in <code>core.clj</code> now. We will not need it.</p>

<p>You may want to use something like Emacs&#8217; <a href="https://github.com/clojure-emacs/cider">cider</a> or LightTable&#8217;s InstaREPL as your REPL environment. But you can use the regular Clojure REPL to build this project, as well. If you are not working with a REPL integrated to your editor, you will need to run <code>(use 'autodjinn.core :reload)</code> to force a reload of the code each time you save.</p>

<h2>Connecting to Gmail</h2>

<p>Our first goal is to connect to our inbox and verify that we can read email from it. To do that, we&#8217;re going to need to use our Gmail address and password &mdash; which we don&#8217;t want to put into our source files. <strong>It&#8217;s bad practice to put a password or a private key into a source file or check it into our repo! Just don&#8217;t do it!</strong></p>

<p>Instead, we will use a nice library called <a href="https://github.com/james-henderson/nomad">nomad</a> to load a config file containing our email address and password. We will add the config file to <code>.gitignore</code> so that it is never saved into our code.</p>

<p>Add the line <code>[jarohen/nomad "0.6.3"]</code> to your <code>project.clj</code> dependencies before moving on, and run <code>lein deps</code> in a console to pull in the dependency.</p>

<p>Back in our <code>core.clj</code> add the require statements for <code>clojure-mail</code> and <code>nomad</code> to your ns macro like this:</p>

<script src="https://gist.github.com/mathias/9863912.js"></script>


<p>Then create a new file in <code>resources/config/autodjinn-config.edn</code>. It should look like this, with your email address and password filled in:</p>

<script src="https://gist.github.com/mathias/9864315.js"></script>


<p>Now open up your <code>.gitignore</code> file and add the following line to it:</p>

<script src="https://gist.github.com/mathias/9866473.js"></script>


<p>Following <a href="https://github.com/james-henderson/nomad#hello-world">nomad&#8217;s README</a>, we need to load our config file and pull out our <code>gmail-username</code> and <code>gmail-password</code> keys. We add to the following to <code>core.clj</code> after the <code>ns</code> macro:</p>

<script src="https://gist.github.com/mathias/8c0849fc0e137f1bd611.js"></script>


<p>Using the <code>get</code> function here is a safe lookup for maps that returns <code>nil</code> if nothing is found for the key. Back in our REPL, we can see this in action with some quick experimentation:</p>

<script src="https://gist.github.com/mathias/9864411.js"></script>


<p>We could also use the shorter <code>(:keyname mymap)</code> syntax here, since symbols are an invocable function that looks up a key in a map. But the <code>get</code> function reads better than <code>(:gmail-username (autodjinn-config))</code> in my opinion.</p>

<p>In your REPL, you should now be able to get the values for <code>gmail-username</code> and <code>gmail-password</code>:</p>

<script src="https://gist.github.com/mathias/9864585.js"></script>


<p>Note that since I&#8217;m in the <code>user</code> namespace here, I had to qualify the vars with their <code>autodjinn.core</code> namespace. If this is confusing, you might want to read up on <a href="http://clojure-doc.org/articles/language/namespaces.html">namespaces in Clojure</a> before moving on. (See also: the &#8216;Namespaces&#8217; section in <a href="http://aphyr.com/posts/311-clojure-from-the-ground-up-logistics">Clojure from the ground up: logistics</a>.)</p>

<p><code>clojure-mail</code> requires us to open a connection to Gmail with the <code>gen-store</code> function (<a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/src/clojure_mail/core.clj#L80-L83">src</a>). We then pass that connection around to various functions to interact with our inbox. Define a var called <code>my-store</code> in your <code>core.clj</code> that does this with our email address and password:</p>

<script src="https://gist.github.com/mathias/9865909.js"></script>


<p>Make sure the <code>(def my-store…</code> above has been run in your REPL and then take a look at our open connection:</p>

<script src="https://gist.github.com/mathias/9865937.js"></script>


<p>The type of <code>my-store</code> should be an <code>IMAPSSLStore</code> as above. If it didn&#8217;t work, you&#8217;ll see a string error message when you try to define <code>my-store</code>.</p>

<h2>Your inbox as a list</h2>

<p>Now we&#8217;ll use our REPL to build up a function that will eventually import all of our email. To start, we can use the <code>inbox</code> function (<a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/src/clojure_mail/core.clj#L198-L201">src</a>) from <code>clojure-mail</code> to get a seq of messages in our inbox. Note that since it is a seq and inboxes can be very large, we limit it with the <code>take</code> function.</p>

<script src="https://gist.github.com/mathias/9866030.js"></script>


<p>If everything is working, you should see a list of of the <code>IMAPMessage</code>s returned by the last line in your REPL.</p>

<p>What if, instead, we wanted to loop over many messages and print out their subjects? We can pull in the <code>message</code> namespace (<a href="https://github.com/owainlewis/clojure-mail/blob/master/src/clojure_mail/message.clj">src</a>) from <code>clojure-mail</code>, which gives us convenience functions for getting at message data.</p>

<p>You&#8217;ll have to be careful running this next line &mdash; on a large inbox it&#8217;ll print out the subject of everything in your inbox! If you have a lot of messages, consider wrapping the call to <code>inbox</code> in a <code>take</code> as above.</p>

<script src="https://gist.github.com/mathias/9866059.js"></script>


<p>Those are the subject lines of the 4 messages in the inbox of my test account, so I know that this is working. Save our <code>doseq</code> line into a function called <code>ingest-inbox</code>; we&#8217;ll come back to it later:</p>

<script src="https://gist.github.com/mathias/9866289.js"></script>


<h2>Examining messages</h2>

<p>Before we move on, let&#8217;s take a look at an individual message and what we can get out of it from the <code>message</code> namespace.</p>

<script src="https://gist.github.com/mathias/9866195.js"></script>


<p>From this, we can see a few things:</p>

<ul>
<li>The ID returned by <code>message/id</code> looks like a good candidate to get good unique IDs for each message when we store the messages. But we might want to strip off those angle brackets first.</li>
<li>The <code>message/message-body</code> function doesn&#8217;t return a string of the body. Instead, it returns a list of maps which contains the <code>text/plain</code> form of the body and the <code>text/html</code> form. We will have to extract each from the map so that we can use the plaintext version for things like language processing. We&#8217;ll also keep the HTML version in case we need it later.</li>
<li>If you started digging in to the <code>message</code> namespace&#8217;s source you may have noticed that we don&#8217;t have functions for getting date sent or date received for a message. Nor can we get a list of addresses CCed or BCCed for the message. We&#8217;ll have to write those functions ourselves.</li>
</ul>


<h2>Cleaning up the IDs</h2>

<p>Let&#8217;s focus on writing a function to clean up the ID returned by the <code>message/id</code> function. Recall that such IDs look like <code>&lt;CAJiAYR90LbbN6k8tVXuhQc8f6bZoK647ycdc7mxF5mVEaoLKHw@mail.gmail.com&gt;</code></p>

<p>The <code>clojure.string</code> namespace provides a <code>replace</code> function which does simple replacement on a string. We can use it like this:</p>

<script src="https://gist.github.com/mathias/9866344.js"></script>


<p>That worked for replacing the angle brackets for the original string. But remember that data structures are immutable in Clojure, including strings. Replacing the first angle bracket didn&#8217;t change the original string when we tried to replace the other angle bracket. We need something that allows us to build up an intermediate value and pass it to the next function. For that, we will use the <a href="http://clojure.github.io/clojure/clojure.core-api.html#clojure.core/-%3e">thread-first</a> macro: <code>-&gt;</code>. It is easiest if I show the macro in use with some comments showing what the intermediate values would be at each step:</p>

<script src="https://gist.github.com/mathias/9866380.js"></script>


<p>It is called the <strong>thread-first</strong> macro because it threads through the first argument to each function. In this case, <code>clojure.string/replace</code>&#8217;s first argument is the string to replace on. So the each successively returned value gets passed to the next function above.</p>

<p>Now that we&#8217;ve figured out how to clean up that ID, we will create a function to clean up any ID we pass it:</p>

<script src="https://gist.github.com/mathias/9866436.js"></script>


<h2>Extracting the message bodies</h2>

<p>Recall the <code>message/message-body</code> call above:</p>

<script src="https://gist.github.com/mathias/9866777.js"></script>


<p>Ideally, we want to write a function that can get the <code>text/plain</code> body out of this value, and another function that can get the <code>text/html</code> body out. Notice that the <code>:content-type</code> values aren&#8217;t quite so simple as just selecting the item in the list where the string <code>text/plain</code> appears. We will need our function to ignore the additional information in the <code>:content-type</code> value, which includes things like string encodings.</p>

<p>Let&#8217;s look at just the first map in the list returned by <code>message/message-body</code>:</p>

<script src="https://gist.github.com/mathias/9866861.js"></script>


<p>If we build a predicate function that can detect when the <code>:content-type</code> key is the type we want, we can use it in a <code>filter</code> function to choose the correct type of body in our functions.</p>

<p>Notice that <code>TEXT/PLAIN</code> and <code>TEXT/HTML</code> are always separated from the rest of the content-type by a semicolon, and it always appears first. You&#8217;d have to look at a few messages from your inbox to arrive at the same conclusion, but I&#8217;ve already done the work and can assure you that the previous statement is true.</p>

<p>Then, an easy to to get at the part of the content-type we want would be to split on the semicolon and take the first element returned:</p>

<script src="https://gist.github.com/mathias/9867049.js"></script>


<p>This leads us to a function to first clean up the content-type string, and then our predicate function to detect if it is the one we want:</p>

<script src="https://gist.github.com/mathias/9867072.js"></script>


<p>To finish off our work on the message bodies, we want to filter the list returned by <code>message/message-body</code>:</p>

<script src="https://gist.github.com/mathias/9867356.js"></script>


<p>And turn it into a function that works for any message bodies list:</p>

<script src="https://gist.github.com/mathias/9867382.js"></script>


<p>Note that we&#8217;ve also used this function to create two convenience functions, one for extracting plaintext bodies and one for extracting HTML bodies. By keeping functions simple and small, we can build up useful functions for our project rather than try to plan it all out ahead of time.</p>

<h2>Getting more information out of the IMAPMessages</h2>

<p>As noted above, we will need to write a few more functions to get the fields of the <code>IMAPMessage</code>s that we cannot get through this version of <code>clojure-mail</code>. Recall that we want to get CC list, BCC list, date sent, and date received values. To do that, we will use Java interop functionality. It&#8217;s really not as bad as it sounds. Remember that the <code>IMAPMessage</code>s we see are Java instances of the <code>IMAPMessage</code> class. Calling a method on an instance is accomplished by using a dot before the method name, with the method in the function position, such as: <code>(.javaMethod some-java-instance)</code></p>

<p>To start, we can look at <code>clojure-mail</code>&#8217;s <a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/project.clj">project.clj</a> and see that it depends on <code>javax.mail</code>. The next step is to find the documentation for the Java implementation of <code>javax.mail.Message</code>, which <a href="http://docs.oracle.com/javaee/6/api/javax/mail/Message.html">lives here</a>.</p>

<p>In the REPL, we can try some of the Java interop on our <code>my-msg</code>:</p>

<script src="https://gist.github.com/mathias/9876540.js"></script>


<p>The datetimes for each message are automatically turned into Clojure instants for us, which is convenient. If we dig into how the <code>clojure-mail.message/to</code> function [<a href="https://github.com/owainlewis/clojure-mail/blob/c3aad67b42aad96405d4c329ca48e29b7960d412/src/clojure_mail/message.clj#L16-L20">src</a>] works, we see that it is using the <code>.getRecipients</code> method. <code>.getRecipients</code> takes the message and a constant of a <code>RecipientType</code>. For our purposes, we want the <code>javax.mail.Message$RecipientType/CC</code> and <code>javax.mail.Message$RecipientType/BCC</code> recipients:</p>

<script src="https://gist.github.com/mathias/9876632.js"></script>


<p>The last line maps the <code>str</code> function across each element returned, so that we get the string representation of the email addresses. That way, our database can just store the strings.</p>

<p>As before, now that we know how to use these methods in the REPL, we write functions in <code>core.clj</code> to take advantage of our newfound knowledge:</p>

<script src="https://gist.github.com/mathias/9876737.js"></script>


<p>In the REPL, it should now be possible to get a nice map representation of all the fields on the message we care about:</p>

<script src="https://gist.github.com/mathias/9876884.js"></script>


<p>Congrats on making it this far. We&#8217;ve used quite a few neat little features of Clojure and the libraries we&#8217;re building this project with to get here.</p>

<p>The last step we&#8217;ll go through in this post is to get these messages into a database.</p>

<h2>Enter Datomic, the immutable datastore</h2>

<p><a href="http://www.datomic.com/">Datomic</a> is a great database layer built on Clojure that gives us a database value representing immutable data. New transactions on the database create new database values. It fits very well with Clojure&#8217;s own concept of <a href="http://clojure.org/state">state and identity</a> because it was designed by the same folks as Clojure. Plus, Datomic is meant to grow and scale in modern environments like AWS, with many backend datastore options to run it on.</p>

<p>There&#8217;s some important reasons why you might choose Datomic as your database for a data science / machine learning application:</p>

<ul>
<li>There are various storage backends, so you can grow from tens of thousands of rows in PostgreSQL on a developer&#8217;s laptop to millions of records (or more) in Riak or DynamoDB on AWS. That is, it has a good migration path from small datasets to big data through the Datomic import/export process</li>
<li>The concept of time associated with each value in Datomic means that we can query for historical data to compare against</li>
<li>Datomic has a lightweight schema compared to a relational database like PostgreSQL. Schemas are just data! When we begin computing new values from our dataset, we can add new types of entities easily at the same time.</li>
<li>Datomic&#8217;s schemas allow us to treat it as a key-value store, relational database, or even build a graph store on top of it, if we need to</li>
</ul>


<p><strong>Note</strong>: I won&#8217;t go through setting up an entire Datomic installation here. It&#8217;s worth reading up on the <a href="http://docs.datomic.com/">docs</a> and the <a href="http://www.datomic.com/rationale.html">rationale</a> behind Datomic&#8217;s design.</p>

<p>You can get the <a href="https://my.datomic.com/downloads/free">Datomic free build</a> if you like, but you will be limited to in-memory stores. It is unlikely that your Gmail inbox will fit into memory on your dev machine. Instead, I recommend signing up for the free <a href="http://www.datomic.com/get-datomic.html">Datomic Pro Starter Edition</a>. (The free Starter Edition is fine because you will not be using this project in a commercial capacity.) Once you have Datomic Pro downloaded and installed in your local Maven, I recommend using the PostgreSQL storage adapter locally with memcached. Follow the guides for configuring storage on the <a href="http://docs.datomic.com/storage.html">Datomic Storage</a> page.</p>

<p>Add the correct line to your <code>project.clj</code> dependencies for the version of Datomic you&#8217;ll be using (mine was <code>[com.datomic/datomic-pro "0.9.4384"]</code> which might be a bit out of date and likely won&#8217;t match yours.) Now we can start using Datomic in our <code>core.clj</code> and our REPL.</p>

<p>The first thing we need is the URI where the Datomic database lives. When we start up the Datomic transactor, you will see a DB URI that looks something like <code>datomic:sql://DBNAMEHERE?jdbc:postgresql://localhost:5432/datomic?user=datomic&amp;password=datomic</code> in the output. Grab that URI and add it to our <code>resources/config/autodjinn-config.edn</code>:</p>

<script src="https://gist.github.com/mathias/9877346.js"></script>


<p>Back at the top of <code>core.clj</code>, save that value to a var as we did with <code>gmail-username</code> and <code>gmail-password</code>:</p>

<script src="https://gist.github.com/mathias/9877374.js"></script>


<p>And then in the REPL:</p>

<script src="https://gist.github.com/mathias/9879199.js"></script>


<p>Note that according to the <a href="http://docs.datomic.com/clojure/index.html#datomic.api/create-database">datomic clojure docs for the create-database function</a>, it returns true if the database was created, and false if it already exists. So running <code>create-database</code> every time we run our script is safe, since it won&#8217;t destroy data.</p>

<p>If the above work in the REPL doesn&#8217;t work, it is likely your code is unable to talk to your running Datomic, or your Datomic transactor is not configured correctly. Diagnose it with Googling and reading the docs until you get it to work, then move on.</p>

<p>Calling <code>(d/db db-connection)</code> gives us the current value of our database. In most cases, we want to just get the most current value. So, we can write a convenience function <code>new-db-val</code> to always get us the current (and possibly different) database value. But there are cases where we want to coordinate several queries and use the same database values for each. In those cases, we won&#8217;t use the function get the latest database value, but rather pass this database value to the queries so that all query against the same state.</p>

<p>In our <code>core.clj</code>, we can add the code we need to create the database, get our connection, and the convenience <code>new-db-val</code> function:</p>

<script src="https://gist.github.com/mathias/9879246.js"></script>


<p>Next, we need to tell Datomic about the schema of our data. Schemas are just data that you run as a transaction on the database. Reading up on the <a href="http://docs.datomic.com/schema.html">Schema</a> page of the Datomic docs might be helpful to understand what&#8217;s going on here. The short version is that we define each attribute of an email and set up its properties. The collection of all attributes together will constitute a <code>mail</code> entity, so we namespace all the attributes under the <code>:mail/</code> namespace.</p>

<script src="https://gist.github.com/mathias/9879323.js"></script>


<p>We add that var def to our <code>core.clj</code> because it is, after all, just data. We may choose later to move it to its own <code>edn</code> file, but for now, it can live in our source code. Next, we want to apply this schema to our database with a transaction. That looks like this:</p>

<script src="https://gist.github.com/mathias/9879355.js"></script>


<p>Now we put that transaction in a convenience function in <code>core.clj</code> that we&#8217;ll run every time we run this file. The function will ensure that our database is &#8216;converged&#8217; to this schema. Running a transaction will create a new database value. But it will not blow away any data that we had in the database by running this transaction many times. It will simply try to update the existing attributes, and nothing in the attributes themselves need change. It is far more work to retract (delete) data in Datomic than it is to add or update it. This leads to much more safety around working with data without worrying that we will destroy data, and it encourages a REPL-based exploration of the data and its history.</p>

<script src="https://gist.github.com/mathias/9879424.js"></script>


<p>Now that our <code>mail</code> entities are defined in Datomic, we can try a query to find all the entity-IDs where any <code>:mail/uid</code> value is present. Read up on the <a href="http://docs.datomic.com/query.html">Query</a> page of the Datomic docs to dig into querying deeper. You might also be interested in the excellent <a href="http://www.learndatalogtoday.org/">Learn Datalog Today</a> website to learn more about querying Datomic with Datalog.</p>

<script src="https://gist.github.com/mathias/9879491.js"></script>


<p>Since we have no <code>mail</code> entities in our database, Datomic returns an empty set. So now we reach the end of task: We can ingest some emails and save them in our database! Return to the <code>ingest-inbox</code> function that we left before. Here&#8217;s what the updated version will look like:</p>

<script src="https://gist.github.com/mathias/9879494.js"></script>


<p>We use the <code>@</code>-sign before the <code>(d/transact…)</code> call because Datomic normally returns a promise of the completed transaction. However, we want to force Datomic to complete each transaction before moving on by deref-ing it with the <code>@</code>-sign. Per the Clojure docs: &#8220;Calls to deref/@ prior to delivery will block.&#8221;</p>

<p>If you run this function in your REPL, you should see it start to ingest your email from Gmail!</p>

<script src="https://gist.github.com/mathias/9879552.js"></script>


<p>Note that this could a take a <strong>long time</strong> if you&#8217;ve chosen to import a really large Gmail inbox! You might want to stop the import at some point; in most REPLs <code>Ctrl-c</code> will stop the running function.</p>

<p>If we query for our entity-IDs again, as above, we should see some values returned!</p>

<p>What does one of those database entities look like when we run it through Datomic&#8217;s <a href="http://docs.datomic.com/clojure/index.html#datomic.api/entity">entity</a> and <a href="http://docs.datomic.com/clojure/index.html#datomic.api/touch">touch</a> functions to instantiate all its attributes?</p>

<script src="https://gist.github.com/mathias/9879636.js"></script>


<h2>Wrapping up</h2>

<p>That&#8217;s it for this blog post. It took a little setup, but we were able to build up a working Gmail import tool with help from our REPL and some nice Clojure libraries.</p>

<p>Next time, we&#8217;ll be looking at doing some basic querying of the data, including getting a count of the number of times each email address has sent you an email.</p>

<p>Comments? Questions? Feel free to contact me at <a href="mailto:contact@mattgauger.com">contact@mattgauger.com</a>. I&#8217;d love to hear from you.</p>

<hr />

<p><a name="cds-gmail-footnote-1"></a>
<strong>1</strong> In this case, machine learning <em>features</em>, which are the input variables for our learning tasks. Not software features that we a client might ask us to implement. See: <a href="https://en.wikipedia.org/wiki/Feature_learning">Feature learning - Wikipedia, the free encyclopedia</a>.
<a href="#cds-gmail-footnote-1-return">↩</a></p>

        
        
    </div>

    <div class="meta">
        <div class="author">
  

<span class="byline author vcard">Posted by <span class="fn">Matt Gauger</span>.</span>
</div>
        <div class="date">












<time datetime="2014-03-30T14:44:00-05:00" pubdate  data-updated="true" >Mar 30<span>th</span>, 2014</time>.</div>
        <div class="tags">

</div>
    </div>

  </article>


  <article class="post">
    
    <h1 class="title"><a href="/blog/2014/03/20/a-quick-dashboard-in-hoplon-and-castra/">A Quick Dashboard in Hoplon &amp; Castra</a></h1>
    <div class="entry">
        <p><em>Note:</em> I began writing a much longer blog post that went into a ton of detail about how to build an app dashboard that used Hoplon and Castra. The kind of dashboard that just consumes JSON API endpoints from another app or other data sources. Such dashboards update on the fly in the browser. Many apps these days need a dashboard like this to monitor stats: worker job queues, database size, average response times, etc.</p>

<p>Rather than that long blog post, I wanted to simply show the steps I would take to build such a dashboard with <a href="http://hoplon.io">Hoplon</a> and <a href="https://github.com/tailrecursion/castra">Castra</a>. I won&#8217;t go into detail here or explain either Hoplon or Castra &mdash; go read on your own first, and also look into <a href="https://github.com/tailrecusion/boot">boot</a>, the build tool this uses.</p>

<p>If you want to follow along, I&#8217;ve provided a <a href="https://github.com/mathias/gleam">repo</a>. The <a href="https://github.com/mathias/gleam/blob/30b4976b313c950c6cc97e64c65036eb21d75378/README.md">README</a> has instructions for getting setup. Assuming you have boot installed, you can just run <code>boot gleam-app</code> to get started.</p>

<p>So here&#8217;s how I&#8217;d build up a dashboard, in several iterations:</p>

<h2>Static data in the browser:</h2>

<p>First, we get some data into the HTML using Hoplon cells:</p>

<script src="https://gist.github.com/mathias/9670739.js"></script>


<p>You&#8217;ll want to <code>git reset --hard 69b070</code> to get to this point.</p>

<h2>Move the data to ClojureScript:</h2>

<p>In <code>src/cljs/gleam/rpc.cljs</code>:</p>

<script src="https://gist.github.com/mathias/9635157.js"></script>


<p>And take out the <code>(def articles…)</code> from <code>index.html.hl</code>. After boot recompiles everything, you should still see the data in the page.</p>

<p>To get to this point, you can run <code>git reset --hard d63f299</code>.</p>

<h2>Move the data to the server side</h2>

<p>Change <code>src/cljs/gleam/rpc.cljs</code> again, this time to make a remote call for data:</p>

<script src="https://gist.github.com/mathias/9671172.js"></script>


<p>On the backend, we need something like this in <code>src/castra/gleam/api/gleam.clj</code>:</p>

<script src="https://gist.github.com/mathias/9671200.js"></script>


<p>The Hoplon HTML file changes in the script tag at the top to use the new ClojureScript remote call and start up the polling:</p>

<script src="https://gist.github.com/mathias/9671220.js"></script>


<p>To get to this point in the example repo, you can do <code>git reset --hard 0bad1e5</code>.</p>

<h2>Real time data</h2>

<p>The last step that I will show is to verify that we are in fact getting regular updates of data from the back end.</p>

<p>Change your Castra Clojure file to look like this:</p>

<script src="https://gist.github.com/mathias/9671661.js"></script>


<p>To get to this point, you can do a <code>git reset --hard f19325</code></p>

<h2>Talking to a remote service.</h2>

<p>The last step here is left as an exercise for the reader. You can imagine replacing the <code>articles</code> function in <code>src/castra/gleam/api/gleam.clj</code> with something that polls a remote JSON API for data. Or you could look at my social news app <a href="http://github.com/mathias/gnar">gnar</a> for inspiration on using a Postgres database for data.</p>

<p>I hope to finish up a post with full explanations soon. Castra is relatively new, and it&#8217;s worth explaining how some of the pieces fit together. My explanation should include more complicated interaction. like user authentication. I will be publishing that blog post after I get back from <a href="http://clojurewest.org">ClojureWest</a> next week!</p>

<p>Let me know what you thought of this post by shooting me an <a href="mailto:contact@mattgauger.com">email</a>. I&#8217;d love to hear from you.</p>

        
        
    </div>

    <div class="meta">
        <div class="author">
  

<span class="byline author vcard">Posted by <span class="fn">Matt Gauger</span>.</span>
</div>
        <div class="date">












<time datetime="2014-03-20T13:29:00-05:00" pubdate  data-updated="true" >Mar 20<span>th</span>, 2014</time>.</div>
        <div class="tags">

</div>
    </div>

  </article>


  <article class="post">
    
    <h1 class="title"><a href="/blog/2014/03/14/agile-data-science-review-and-thoughts/">Agile Data Science: Review and Thoughts</a></h1>
    <div class="entry">
        <p><a href="http://shop.oreilly.com/product/0636920025054.do">
  <img src="//blog.mattgauger.com/images/agile_data_science_cover.gif" alt="Agile Data Science cover" style="display: block; float:right; margin: 10px;">
</a></p>

<p>Recently, I read the book <a href="http://shop.oreilly.com/product/0636920025054.do">Agile Data Science</a> by Russell Jurney. The book covers data science and how the author applies an agile workflow and powerful tooling to accomplish tasks. While I found the book interesting, and would recommend it as a good introduction, I have some issues with the book that I&#8217;d like to discuss. I&#8217;d like to go over the book and the tools briefly, if only to save my thoughts for later.</p>

<p>A quick note: data science is actively being defined by the web community as the process of analyzing large data sets with statistics and other approaches. That definition is ongoing and changing all the time. Big Data is the term that the industry seems to be using for such large datasets. You&#8217;ll also see the terms machine learning, analytics, and recommender systems mentioned: these are all various sub-topics that I won&#8217;t cover in depth here.</p>

<p>The book centers around the use of <a href="http://hadoop.apache.org/">Hadoop</a>. In turn, Hadoop is commanded by writing and running <a href="https://pig.apache.org/">Apache Pig</a> scripts in the book. Pig allows you to write workflows in a high-level scripting language that may compose many Hadoop jobs into one system. With Pig, you need not worry about the specifics of what each Hadoop job is doing when you write a Pig script.</p>

<p>Hadoop is patterned after Google&#8217;s <a href="http://static.googleusercontent.com/media/research.google.com/en/us/archive/mapreduce-osdi04.pdf">MapReduce paper</a>. Google had large clusters of computers and large data sets that it wanted to process on those clusters. What they came up with was a simple idea: Write a single program that would specify a <code>map</code> function to run across tuples of all the input data. Add a <code>reduce</code> function that compiles that output down into the expected format. MapReduce coordinates deploying the program to each worker machine, divvying up the input data across the different machines, gathering up the results, and handling things like restarts after failures. This was a huge success inside Google, and Hadoop implements that architecture with improvements.</p>

<p>It should be noted that this MapReduce architecture is essentially batch-processing for large amounts of data. The same system would have a hard time with continuous streams of data.</p>

<p>Hadoop is, unfortunately, my first stumbling block with learning to process big data.</p>

<p>Configuring and running Hadoop is not easy. I have far more experience as a developer than a sysadmin (or today&#8217;s term: devops engineer). There exists more than one &#8220;distribution&#8221; of Hadoop and more than one versioning scheme between those. This means that understanding what&#8217;s available, how to configure it, and whether search results are relevant to you is quite hard for the unexperienced.  Imagine the confusion of trying to install a Debian Linux distro and only being able to find instructions for Red Hat Linux; further, not being able to tell what the problem was when it wouldn’t boot and printed a Debian-specific error.</p>

<p>It seems like Hadoop is designed for to be run by someone whose full-time job is to configure and maintain that cluster. That person will need to have enough experience with all the different choices to have an opinion on them. For a developer wanting to run things locally before committing to configuring (and paying for!) a full cluster out on AWS, it was daunting.</p>

<p>Luckily for me, <a href="https://github.com/charlesflynn">Charles Flynn</a> has created a neat repo on Github at <a href="https://github.com/charlesflynn/agiledata">charlesflynn/agiledata</a>. It builds a local development VM for the Agile Data Science book, with all the dependencies installed and the book&#8217;s code in the right place to run. With that project, I was able to get up and running with the project quickly and found it useful to not have to sink anymore time into configuring Hadoop. I&#8217;d like to give another shout-out to Charles for this great resource and the work done to make sure it works.</p>

<p>The book has the reader work with email data: your Gmail inbox pulled locally for analyzing. I thought this was neat, in itself. Many data science tools use free datasets; as a result working with those datasets may not be the most interesting problem space to you. But insights about your own communication and how others communicate with you is something you might find more interesting.</p>

<p>After explaining Hadoop, Pig, and a few other tools, the rest of the book follows a fairly lightweight &#8220;recipe&#8221; format. Each chapter explains the goal and how it fits in an &#8220;agile data science&#8221; workflow. Then, some code is presented, and then we see what kinds of results we can take from that step. Once this pattern is set up, the book moves fairly quickly through some rather interesting data wrangling. By the end, the reader has built several data analysis scripts and a simple web app put together with MongoDB, Python Flask, and D3.js graphs to display all the results.</p>

<p>At times, though, the quick recipe format seemed to explain too little. There was little explanation of how Pig script syntax worked or how to understand what was going on under the covers. What this book is not: an exhaustive guide to how to write Pig scripts, how to pick approaches to analyzing a dataset, or how to compose these systems in production in the wild.  Also missing were any mention of performance tuning or what other algorithms might be considered.</p>

<p>Which seems like an awful lot to be missing, but for this book that would have been diversions that bogged the book down.</p>

<p>To the author&#8217;s benefit, I finished the book, and finished it far faster than I expected I would. I cam away having done almost all of the book&#8217;s examples (helped a great deal by the excellent virtual machine repo from Charles Flynn mentioned above). And, I had a deeper understanding and respect for tools that I&#8217;d never used before.</p>

<h2>Final thoughts</h2>

<p>When it comes down to it, I wouldn&#8217;t recommend Agile Data Science to read on its own. I&#8217;d recommend that you used it as a quick introductory book to build familiarity and confidence, so that you could dive into a deeper resource afterwards. I&#8217;d also recommend it if you&#8217;re a developer who isn&#8217;t going to be doing data science as your full time job but are curious about the tools and practices, this book would be a good read.</p>

<h2>What I&#8217;m doing next</h2>

<p>Almost immediately after finishing this book, I attended an event at a nearby college to talk about <a href="http://storm.incubator.apache.org/">Apache Storm</a>. Our company blog <a href="http://bendyworks.com/geekville/articles/2014/2/uw-big-data-event-presents-storm">covered the event</a> if you&#8217;re curious.</p>

<p>Storm is a tool that came out of Twitter for processing streams of big data. If you think about it, Twitter has one of the biggest streaming data sets ever. They need to use that streaming data for everything from recommendations to analytics to top tweet/hashtag rankings.</p>

<p>After attending the event and having run a word-counting topology (Storm&#8217;s term for a workflow that may contain many data-processing jobs) out on a cluster, I began to see the potential of using Storm.</p>

<p>Plus, Storm is far friendlier to local development on a laptop. One can run it with a simple command line tool or even from inside your Java or Clojure code. Or, perhaps most simply, from inside the Clojure REPL.</p>

<p>The other plus here is that Storm is mostly written in Clojure and has a full Clojure API. Combined with a few other Clojure tools that I prefer, like <a href="http://www.datomic.com/">Datomic</a>, <a href="https://github.com/ring-clojure/ring">Ring</a>, and <a href="http://keminglabs.com/c2/">C2</a>, I can see a toolset similar to that used in Agile Data Science. This toolset has the benefit of using the same language for everything. And, Clojure is already well-suited for data manipulation and processing.</p>

<p>So I began to rewrite the examples in Agile Data Science in Clojure. I am hoping to make enough progress to begin posting some of the code with explanations in blog format. Stay tuned for that.</p>

        
        
    </div>

    <div class="meta">
        <div class="author">
  

<span class="byline author vcard">Posted by <span class="fn">Matt Gauger</span>.</span>
</div>
        <div class="date">












<time datetime="2014-03-14T19:53:00-05:00" pubdate  data-updated="true" >Mar 14<span>th</span>, 2014</time>.</div>
        <div class="tags">

</div>
    </div>

  </article>


<ul class="pager">
  
  
    <li>
    <a href="/blog/page/2/" class="next">Next</a>
    </li>
  
</ul>

<a href="/blog/archives" class="center">
  <i class="icon-th-list"></i> 
  Blog Archives
</a>

  </article>
</div>

    <hr />
	  <footer class="footer"><div class="row">
  <div class="offset2 span2">
    <img src="/images/mathiasx.jpg" alt="portrait">
  </div>
  <div class="span3">
    <p><a href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="https://github-camo.global.ssl.fastly.net/cc898278e77203243a0b63be665d38fa75dcf04a/687474703a2f2f692e6372656174697665636f6d6d6f6e732e6f72672f6c2f62792d6e632d73612f332e302f38387833312e706e67" alt="Creative Commons License Image" data-canonical-src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" style="max-width:100%;"></a>
blog.mattgauger.com
by <a href="http://blog.mattgauger.com">Matt Gauger</a> is licensed under a <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Creative Commons
Attribution-NonCommercial-ShareAlike 3.0 Unported License</a>

  </div>
  <div class="offset1 span3">
    <ul class="nav nav-list">
      <li><a href="https://github.com/mathias">Github</a></li>
      <li><a href="/presentations">Presentations</a></li>
      <li><a href="http://feeds.feedburner.com/MattGaugerBlog" title="Atom XML/RSS Feed">Atom Feed</a></li>
    </ul>
  </div>
</div>
</footer>
  </div>
	<script src="//ajax.googleapis.com/ajax/libs/jquery/1.9.1/jquery.min.js"></script>

<script src="/javascripts/bootstrap-alert.js"></script>
<script src="/javascripts/bootstrap-button.js"></script>
<script src="/javascripts/bootstrap-collapse.js"></script>

<script type="text/javascript">

  var _gaq = _gaq || [];
  _gaq.push(['_setAccount', 'UA-38944731-1']);
  _gaq.push(['_trackPageview']);

  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();

</script>

</body>
</html>
